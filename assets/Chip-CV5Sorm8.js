import{S as Z,p as _,b as d,s as U,c as v,n as k,i as Q,d as A,t as J,e as C,f as Y,g as ee,h as B,k as G,r as m,l as te,m as se,u as re,j as o}from"./index-Lb3Kz69r.js";var ie=class extends Z{constructor(e,t){super(),this.options=t,this.#s=e,this.#i=null,this.#r=_(),this.bindMethods(),this.setOptions(t)}#s;#e=void 0;#f=void 0;#t=void 0;#a;#u;#r;#i;#m;#h;#d;#o;#c;#n;#p=new Set;bindMethods(){this.refetch=this.refetch.bind(this)}onSubscribe(){this.listeners.size===1&&(this.#e.addObserver(this),H(this.#e,this.options)?this.#l():this.updateResult(),this.#x())}onUnsubscribe(){this.hasListeners()||this.destroy()}shouldFetchOnReconnect(){return D(this.#e,this.options,this.options.refetchOnReconnect)}shouldFetchOnWindowFocus(){return D(this.#e,this.options,this.options.refetchOnWindowFocus)}destroy(){this.listeners=new Set,this.#v(),this.#S(),this.#e.removeObserver(this)}setOptions(e){const t=this.options,s=this.#e;if(this.options=this.#s.defaultQueryOptions(e),this.options.enabled!==void 0&&typeof this.options.enabled!="boolean"&&typeof this.options.enabled!="function"&&typeof d(this.options.enabled,this.#e)!="boolean")throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");this.#R(),this.#e.setOptions(this.options),t._defaulted&&!U(this.options,t)&&this.#s.getQueryCache().notify({type:"observerOptionsUpdated",query:this.#e,observer:this});const r=this.hasListeners();r&&q(this.#e,s,this.options,t)&&this.#l(),this.updateResult(),r&&(this.#e!==s||d(this.options.enabled,this.#e)!==d(t.enabled,this.#e)||v(this.options.staleTime,this.#e)!==v(t.staleTime,this.#e))&&this.#g();const i=this.#b();r&&(this.#e!==s||d(this.options.enabled,this.#e)!==d(t.enabled,this.#e)||i!==this.#n)&&this.#y(i)}getOptimisticResult(e){const t=this.#s.getQueryCache().build(this.#s,e),s=this.createResult(t,e);return ae(this,s)&&(this.#t=s,this.#u=this.options,this.#a=this.#e.state),s}getCurrentResult(){return this.#t}trackResult(e,t){return new Proxy(e,{get:(s,r)=>(this.trackProp(r),t?.(r),r==="promise"&&!this.options.experimental_prefetchInRender&&this.#r.status==="pending"&&this.#r.reject(new Error("experimental_prefetchInRender feature flag is not enabled")),Reflect.get(s,r))})}trackProp(e){this.#p.add(e)}getCurrentQuery(){return this.#e}refetch({...e}={}){return this.fetch({...e})}fetchOptimistic(e){const t=this.#s.defaultQueryOptions(e),s=this.#s.getQueryCache().build(this.#s,t);return s.fetch().then(()=>this.createResult(s,t))}fetch(e){return this.#l({...e,cancelRefetch:e.cancelRefetch??!0}).then(()=>(this.updateResult(),this.#t))}#l(e){this.#R();let t=this.#e.fetch(this.options,e);return e?.throwOnError||(t=t.catch(k)),t}#g(){this.#v();const e=v(this.options.staleTime,this.#e);if(Q||this.#t.isStale||!A(e))return;const s=J(this.#t.dataUpdatedAt,e)+1;this.#o=C.setTimeout(()=>{this.#t.isStale||this.updateResult()},s)}#b(){return(typeof this.options.refetchInterval=="function"?this.options.refetchInterval(this.#e):this.options.refetchInterval)??!1}#y(e){this.#S(),this.#n=e,!(Q||d(this.options.enabled,this.#e)===!1||!A(this.#n)||this.#n===0)&&(this.#c=C.setInterval(()=>{(this.options.refetchIntervalInBackground||Y.isFocused())&&this.#l()},this.#n))}#x(){this.#g(),this.#y(this.#b())}#v(){this.#o&&(C.clearTimeout(this.#o),this.#o=void 0)}#S(){this.#c&&(C.clearInterval(this.#c),this.#c=void 0)}createResult(e,t){const s=this.#e,r=this.options,i=this.#t,u=this.#a,n=this.#u,c=e!==s?e.state:this.#f,{state:p}=e;let a={...p},x=!1,l;if(t._optimisticResults){const h=this.hasListeners(),S=!h&&H(e,t),y=h&&q(e,s,t,r);(S||y)&&(a={...a,...ee(p.data,e.options)}),t._optimisticResults==="isRestoring"&&(a.fetchStatus="idle")}let{error:N,errorUpdatedAt:F,status:b}=a;l=a.data;let W=!1;if(t.placeholderData!==void 0&&l===void 0&&b==="pending"){let h;i?.isPlaceholderData&&t.placeholderData===n?.placeholderData?(h=i.data,W=!0):h=typeof t.placeholderData=="function"?t.placeholderData(this.#d?.state.data,this.#d):t.placeholderData,h!==void 0&&(b="success",l=B(i?.data,h,t),x=!0)}if(t.select&&l!==void 0&&!W)if(i&&l===u?.data&&t.select===this.#m)l=this.#h;else try{this.#m=t.select,l=t.select(l),l=B(i?.data,l,t),this.#h=l,this.#i=null}catch(h){this.#i=h}this.#i&&(N=this.#i,l=this.#h,F=Date.now(),b="error");const w=a.fetchStatus==="fetching",T=b==="pending",E=b==="error",L=T&&w,V=l!==void 0,f={status:b,fetchStatus:a.fetchStatus,isPending:T,isSuccess:b==="success",isError:E,isInitialLoading:L,isLoading:L,data:l,dataUpdatedAt:a.dataUpdatedAt,error:N,errorUpdatedAt:F,failureCount:a.fetchFailureCount,failureReason:a.fetchFailureReason,errorUpdateCount:a.errorUpdateCount,isFetched:a.dataUpdateCount>0||a.errorUpdateCount>0,isFetchedAfterMount:a.dataUpdateCount>c.dataUpdateCount||a.errorUpdateCount>c.errorUpdateCount,isFetching:w,isRefetching:w&&!T,isLoadingError:E&&!V,isPaused:a.fetchStatus==="paused",isPlaceholderData:x,isRefetchError:E&&V,isStale:M(e,t),refetch:this.refetch,promise:this.#r,isEnabled:d(t.enabled,e)!==!1};if(this.options.experimental_prefetchInRender){const h=R=>{f.status==="error"?R.reject(f.error):f.data!==void 0&&R.resolve(f.data)},S=()=>{const R=this.#r=f.promise=_();h(R)},y=this.#r;switch(y.status){case"pending":e.queryHash===s.queryHash&&h(y);break;case"fulfilled":(f.status==="error"||f.data!==y.value)&&S();break;case"rejected":(f.status!=="error"||f.error!==y.reason)&&S();break}}return f}updateResult(){const e=this.#t,t=this.createResult(this.#e,this.options);if(this.#a=this.#e.state,this.#u=this.options,this.#a.data!==void 0&&(this.#d=this.#e),U(t,e))return;this.#t=t;const s=()=>{if(!e)return!0;const{notifyOnChangeProps:r}=this.options,i=typeof r=="function"?r():r;if(i==="all"||!i&&!this.#p.size)return!0;const u=new Set(i??this.#p);return this.options.throwOnError&&u.add("error"),Object.keys(this.#t).some(n=>{const g=n;return this.#t[g]!==e[g]&&u.has(g)})};this.#C({listeners:s()})}#R(){const e=this.#s.getQueryCache().build(this.#s,this.options);if(e===this.#e)return;const t=this.#e;this.#e=e,this.#f=e.state,this.hasListeners()&&(t?.removeObserver(this),e.addObserver(this))}onQueryUpdate(){this.updateResult(),this.hasListeners()&&this.#x()}#C(e){G.batch(()=>{e.listeners&&this.listeners.forEach(t=>{t(this.#t)}),this.#s.getQueryCache().notify({query:this.#e,type:"observerResultsUpdated"})})}};function ne(e,t){return d(t.enabled,e)!==!1&&e.state.data===void 0&&!(e.state.status==="error"&&t.retryOnMount===!1)}function H(e,t){return ne(e,t)||e.state.data!==void 0&&D(e,t,t.refetchOnMount)}function D(e,t,s){if(d(t.enabled,e)!==!1&&v(t.staleTime,e)!=="static"){const r=typeof s=="function"?s(e):s;return r==="always"||r!==!1&&M(e,t)}return!1}function q(e,t,s,r){return(e!==t||d(r.enabled,e)===!1)&&(!s.suspense||e.state.status!=="error")&&M(e,s)}function M(e,t){return d(t.enabled,e)!==!1&&e.isStaleByTime(v(t.staleTime,e))}function ae(e,t){return!U(e.getCurrentResult(),t)}var X=m.createContext(!1),oe=()=>m.useContext(X);X.Provider;function ce(){let e=!1;return{clearReset:()=>{e=!1},reset:()=>{e=!0},isReset:()=>e}}var le=m.createContext(ce()),ue=()=>m.useContext(le),he=(e,t)=>{(e.suspense||e.throwOnError||e.experimental_prefetchInRender)&&(t.isReset()||(e.retryOnMount=!1))},de=e=>{m.useEffect(()=>{e.clearReset()},[e])},pe=({result:e,errorResetBoundary:t,throwOnError:s,query:r,suspense:i})=>e.isError&&!t.isReset()&&!e.isFetching&&r&&(i&&e.data===void 0||te(s,[e.error,r])),fe=e=>{if(e.suspense){const s=i=>i==="static"?i:Math.max(i??1e3,1e3),r=e.staleTime;e.staleTime=typeof r=="function"?(...i)=>s(r(...i)):s(r),typeof e.gcTime=="number"&&(e.gcTime=Math.max(e.gcTime,1e3))}},me=(e,t)=>e.isLoading&&e.isFetching&&!t,ge=(e,t)=>e?.suspense&&t.isPending,K=(e,t,s)=>t.fetchOptimistic(e).catch(()=>{s.clearReset()});function be(e,t,s){const r=oe(),i=ue(),u=se(),n=u.defaultQueryOptions(e);u.getDefaultOptions().queries?._experimental_beforeQuery?.(n),n._optimisticResults=r?"isRestoring":"optimistic",fe(n),he(n,i),de(i);const g=!u.getQueryCache().get(n.queryHash),[c]=m.useState(()=>new t(u,n)),p=c.getOptimisticResult(n),a=!r&&e.subscribed!==!1;if(m.useSyncExternalStore(m.useCallback(x=>{const l=a?c.subscribe(G.batchCalls(x)):k;return c.updateResult(),l},[c,a]),()=>c.getCurrentResult(),()=>c.getCurrentResult()),m.useEffect(()=>{c.setOptions(n)},[n,c]),ge(n,p))throw K(n,c,i);if(pe({result:p,errorResetBoundary:i,throwOnError:n.throwOnError,query:u.getQueryCache().get(n.queryHash),suspense:n.suspense}))throw p.error;return u.getDefaultOptions().queries?._experimental_afterQuery?.(n,p),n.experimental_prefetchInRender&&!Q&&me(p,r)&&(g?K(n,c,i):u.getQueryCache().get(n.queryHash)?.promise)?.catch(k).finally(()=>{c.updateResult()}),n.notifyOnChangeProps?p:c.trackResult(p)}function P(e,t){return be(e,ie)}function Te({showBackButton:e=!1,backButtonText:t="돌아가기"}){const s=re();return o.jsx("nav",{className:"bg-white/80 backdrop-blur-sm shadow-sm fixed w-full top-0 z-50",children:o.jsx("div",{className:"max-w-6xl mx-auto px-6 py-4",children:o.jsxs("div",{className:"flex justify-between items-center",children:[o.jsx("button",{onClick:()=>s("/"),className:"font-bold text-2xl text-purple-600 hover:scale-105 transform transition-all duration-300 cursor-pointer",children:"포트폴리오"}),e?o.jsxs("button",{onClick:()=>s("/"),className:"flex items-center space-x-2 text-gray-700 hover:text-purple-600 hover:scale-105 transform transition-all duration-300 cursor-pointer",children:[o.jsx("i",{className:"ri-arrow-left-line text-xl"}),o.jsx("span",{children:t})]}):o.jsxs("div",{className:"hidden md:flex space-x-8",children:[o.jsx("a",{href:"#about",className:"text-gray-700 hover:text-purple-400 transition-all duration-300 hover:scale-105 cursor-pointer",children:"소개"}),o.jsx("a",{href:"#experience",className:"text-gray-700 hover:text-purple-400 transition-all duration-300 hover:scale-105 cursor-pointer",children:"경력"}),o.jsx("a",{href:"#projects",className:"text-gray-700 hover:text-purple-400 transition-all duration-300 hover:scale-105 cursor-pointer",children:"프로젝트"}),o.jsx("a",{href:"#contact",className:"text-gray-700 hover:text-purple-400 transition-all duration-300 hover:scale-105 cursor-pointer",children:"연락처"})]}),o.jsx("button",{className:"md:hidden hover:rotate-180 transition-transform duration-300",children:o.jsx("i",{className:"ri-menu-line text-2xl text-gray-700"})})]})})})}function Ee(){return o.jsx("footer",{className:"bg-white py-8 px-6",children:o.jsx("div",{className:"max-w-6xl mx-auto",children:o.jsx("div",{className:"flex flex-col md:flex-row justify-end items-center",children:o.jsx("p",{className:"text-gray-600 mb-4 md:mb-0",children:"© 2025 Park Haebeen"})})})})}const ye="/portfolio/assets/butter-logo-DAKwGqM5.png",xe="/portfolio/assets/jiransoft-logo-CTWEcLyT.png",$="/portfolio/assets/lgu1-B4A5f2n7.png",ve="/portfolio/assets/lgu2-44iI3FAj.png",z=[{name:"버터",position:"프론트엔드 개발자 | 대리",period:"2024.03 - 재직중",description:"대규모 웹 애플리케이션 개발 및 팀 리딩 경험",logo:ye},{name:"지란지교소프트",position:"프론트엔드 개발자 | 사원",period:"2018.12 - 2022.07",description:"프론트엔드와 백엔드를 모두 담당하며 다양한 프로젝트 경험",logo:xe}],O=[{id:1,title:"LG유플러스 멤버십 통합 서비스",description:"LG유플러스 멤버십 앱 기능을 유플닷컴으로 내재화한 앱 내 웹뷰 기반 통합 서비스로, 네이티브 앱 업데이트 없이도 실시간 기능 배포와 크로스 플랫폼 호환성을 확보한 하이브리드 아키텍처를 구현했습니다.",detailedDescription:"이 프로젝트는 월 10만명 이상의 VIP 고객이 이용하는 대규모 멤버십 플랫폼입니다. VIP콕, 멤버십 사용처, 유플투쁠 이벤트 등 핵심 기능들을 웹뷰로 통합하여 사용자 경험을 일원화했습니다. 특히 iOS WebView 환경에서 발생하는 복잡한 렌더링 이슈를 해결하고, 대기열 시스템을 통해 동시 접속자 급증 시에도 안정적인 서비스를 제공합니다. React Suspense와 TanStack Query를 활용한 상태 관리 최적화, 무한스크롤 페이지네이션 구현, 그리고 VVIP/VIP 차등 정책에 따른 복잡한 사용자 상태 관리까지 전체 프론트엔드 아키텍처를 담당했습니다.",tech:["Next.js 14","React 18","TypeScript","Zustand","TanStack Query","SCSS","NX","Playwright","Storybook"],period:"2024.03 - 2025.01",role:"Frontend Developer",challenges:["iOS WebView 백화 현상 해결 (position: sticky GPU 컴포지팅 레이어 이슈)","대기열 시스템 구현 및 무한로딩 현상 해결","VVIP/VIP 차등 정책에 따른 복잡한 사용자 상태 관리","동시 접속자 급증 시 서버 부하 및 사용자 대기 문제","앱 업데이트 없이 실시간 기능 배포를 위한 웹뷰 최적화"],contributions:["iOS WebView 렌더링 이슈 해결로 앱 업데이트 없이도 안정적 서비스 제공","대기열 시스템 구현으로 동시 접속자 급증 시 서버 다운 방지","VIP콕 서비스 개발로 VIP 고객 만족도 향상 및 혜택 이용률 증대","무한스크롤 페이지네이션 최적화로 페이지 로딩 성능 30% 개선","React Suspense 적용으로 서브 페이지 렌더링 단위 분리 및 사용자 경험 개선"],images:[$,ve],githubUrl:"",liveUrl:"",imageUrl:$,reflection:["이 프로젝트를 통해 가장 큰 깨달음은 '문제의 본질을 파악하는 것의 중요성'이었습니다. iOS WebView 백화 현상을 해결할 때, 처음에는 데이터 로딩 문제로 오해하고 글로벌 로딩 컴포넌트를 제거하고 React Suspense를 적용하는 등 여러 시행착오를 겪었습니다. 하지만 결국 브라우저 렌더링 파이프라인 문제라는 근본 원인을 찾아내고, position: sticky 요소의 GPU 컴포지팅 레이어 생성 과정에서 iOS WebKit의 paint invalidation 실패가 원인임을 파악할 수 있었습니다.","또한 '단순한 해결책이 때로는 최고의 해결책'이라는 것을 배웠습니다. 복잡한 CSS 변경이나 DOM 조작 대신 window.scrollTo()라는 단순한 API로 문제를 해결할 수 있었던 것처럼, 과도한 엔지니어링보다는 문제의 핵심을 정확히 파악하는 것이 중요하다는 것을 깨달았습니다. 이는 앞으로 어떤 기술적 도전을 만나더라도 근본 원인을 찾아내는 사고방식을 기르는 데 큰 도움이 되었습니다.","기술적으로는 React/Next.js 생태계의 깊이를 이해하게 되었고, 특히 Suspense와 Error Boundary를 활용한 에러 처리, TanStack Query의 캐싱 전략, 그리고 WebView 환경의 특수성을 고려한 개발 방법론을 익힐 수 있었습니다. 대기열 시스템 구현 과정에서 useEffect 의존성 배열 관리의 중요성과, 무한스크롤에서 메모리 누수 방지를 위한 가비지 컬렉션 최적화 등 실무에서 바로 적용할 수 있는 구체적인 기술들을 습득했습니다.","팀 협업 측면에서는 복잡한 이슈를 체계적으로 분석하고 해결하는 과정에서 동료들과의 소통과 지식 공유의 중요성을 다시 한번 느꼈습니다. 특히 iOS WebView 이슈 해결 과정에서 팀원들과 함께 문제를 분석하고, 다양한 접근 방법을 시도해보며 최종 해결책을 찾아가는 과정에서 팀워크의 가치를 깊이 체감했습니다. 앞으로도 이런 협업을 통해 더 나은 솔루션을 만들어갈 수 있을 것 같습니다."]},{id:2,title:"고사장 브라우저 (시험 감독용 보안 브라우저)",description:"시험 부정행위 방지를 위한 보안 브라우저로, 운영체제 레벨 보안 모듈을 통합하여 키보드/마우스 입력 차단, 화면 캡처 방지, 클립보드 제어 등 다중 보안 계층을 구현한 Electron 기반 데스크톱 애플리케이션입니다.",detailedDescription:"이 프로젝트는 온라인 시험 환경에서 응시자의 부정행위를 방지하기 위한 보안 브라우저 개발입니다. Rust 기반 proctor-internal 모듈을 Electron에 통합하여 시스템 레벨 보안 기능을 구현했으며, WebContents → WebView 마이그레이션을 통해 UI 가려짐 문제를 해결했습니다. 멀티 탭 시스템과 URL 스킴 처리, 실시간 상태 모니터링 기능을 구현하여 시험 감독자가 원격으로 브라우저를 제어할 수 있도록 했습니다. 특히 보안 모듈 충돌 방지를 위한 뮤텍스 기반 동기화 시스템과 크로스 플랫폼 호환성을 위한 각 OS별 보안 API 통합까지 전체 아키텍처를 담당했습니다.",tech:["Electron 26","React 18","TypeScript","Recoil","Rust","Node.js","Express.js","SCSS","Webpack 5","Electron Builder"],period:"2024.01 - 2024.12",role:"Full-stack Developer",challenges:["WebContents 사용 시 브라우저 UI가 웹 콘텐츠에 가려지는 문제","보안 모듈 간 충돌로 인한 시스템 불안정성","크로스 플랫폼 환경에서 각 OS별 보안 API 차이점 해결","Windows 키 차단 기능이 제대로 작동하지 않는 버그","멀티 탭 환경에서 메모리 사용량 최적화","Rust 기반 네이티브 모듈을 Electron에 안전하게 통합"],contributions:["WebView 마이그레이션으로 UI 가려짐 문제 해결 및 사용자 경험 100% 개선","뮤텍스 기반 동기화 시스템으로 보안 모듈 충돌 방지 및 시스템 안정성 확보","멀티 탭 최적화로 메모리 사용량 60% 감소 (포커스된 탭만 활성화)","URL 스킴 처리 시스템 구현으로 외부에서 브라우저 원격 제어 가능","실시간 상태 모니터링 시스템으로 웹캠, 화면공유, 스마트폰 연결 상태 표시","크로스 플랫폼 호환성 확보로 macOS/Windows/Linux 지원"],images:[],githubUrl:"",liveUrl:"",imageUrl:"",reflection:["이 프로젝트를 통해 가장 큰 깨달음은 '시스템 전체를 이해하는 것의 중요성'이었습니다. Windows 키 차단 버그를 해결할 때, 처음에는 코드 로직만 수정하려고 했지만 결국 package.json의 의존성 관리와 네이티브 모듈 빌드 과정까지 전체적으로 이해해야 해결할 수 있다는 것을 배웠습니다. 단순히 문제가 발생한 부분만 수정하는 것이 아니라 전체 시스템의 연관성을 파악하는 것이 중요하다는 것을 깨달았습니다.","또한 '보안과 사용성의 균형'을 맞추는 것이 얼마나 어려운지 체감했습니다. 강력한 보안 기능을 구현하면서도 직관적인 사용자 경험을 제공하기 위해 WebContents에서 WebView로 아키텍처를 변경하는 등 여러 시행착오를 겪었습니다. 이 과정에서 사용자 중심의 기술적 의사결정이 얼마나 중요한지 배웠습니다.","기술적으로는 Electron 생태계의 깊이를 이해하게 되었고, 특히 네이티브 모듈 통합, IPC 통신, 크로스 플랫폼 개발의 복잡성을 경험했습니다. Rust와 TypeScript를 함께 사용하면서 각 언어의 장점을 살린 하이브리드 개발 방법론을 익힐 수 있었고, Inspector 패턴을 활용한 확장 가능한 보안 모듈 아키텍처 설계 능력을 기를 수 있었습니다.","개인적으로는 '근본 원인을 찾아내는 사고방식'을 기르게 되었습니다. 보안 모듈 충돌 문제를 해결할 때 표면적인 증상만 보고 해결하려다가 실패했지만, 결국 동시성 프로그래밍의 근본 원인을 파악하고 뮤텍스 기반 해결책을 도입하여 완전히 해결할 수 있었습니다. 앞으로 어떤 복잡한 문제를 만나더라도 근본 원인을 찾아내는 분석력을 기를 수 있었습니다."]},{id:3,title:"고사장 프로터 웹 시스템 (실시간 감독 플랫폼)",description:"온라인 시험 환경에서 감독관이 응시자를 실시간으로 모니터링할 수 있는 웹 기반 감독 시스템입니다. WebRTC 기반 멀티 스트림 관리, Socket.IO 실시간 통신, 동적 그리드 레이아웃을 통해 PC와 모바일 기기에서 동시에 전송되는 비디오/오디오 스트림을 효율적으로 처리하며, 실시간 채팅과 상태 동기화를 제공합니다.",detailedDescription:"이 프로젝트는 코로나19로 인한 온라인 시험 환경 확산에 따라 기존 오프라인 감독 시스템을 웹 기반 실시간 감독 시스템으로 전환하는 프로젝트입니다. Vue 3 Composition API와 TypeScript를 활용하여 WebRTC 기반 멀티 스트림 실시간 감독 시스템을 개발했으며, vue3-grid-layout-next를 통한 동적 화면 배치와 실시간 레이아웃 조정 기능을 구현했습니다. 폴링 방식에서 Socket.IO 기반 실시간 통신으로 전환하여 네트워크 트래픽을 90% 감소시키고 응답 속도를 50배 개선했습니다. Pinia를 활용한 전역 상태 관리, 실시간 채팅 및 알림 시스템을 구현하여 감독 효율성을 크게 향상시켰습니다.",tech:["Vue 3","TypeScript","Pinia","Socket.IO","WebRTC","PrimeVue","SCSS","Vite","Docker","Nginx"],period:"2024.01 - 2024.12",role:"Frontend Developer",challenges:["WebRTC 멀티 스트림 동기화 및 DOM 참조 문제","폴링 방식의 서버 부하 증가 및 실시간성 부족","동적 그리드 레이아웃에서 비동기 처리로 인한 UI 업데이트 지연","실시간 상태 동기화에서 발생하는 데이터 불일치","타임존 처리로 인한 서버 UTC 시간과 클라이언트 로컬 시간 불일치","Socket.IO 연결 상태 관리 및 재연결 처리"],contributions:["WebRTC 기반 멀티 스트림 실시간 감독 시스템 개발 (PC/모바일 동시 지원)","폴링에서 Socket.IO 기반 실시간 통신으로 전환하여 네트워크 트래픽 90% 감소","vue3-grid-layout-next를 활용한 동적 화면 배치 및 실시간 레이아웃 조정 구현","Pinia를 활용한 전역 상태 관리로 인증, 시험, 스트림 상태 동기화 최적화","실시간 채팅, 알림, 상태 변경을 통한 감독 효율성 향상 및 사용자 경험 개선","타임존 처리 시스템 구현으로 글로벌 서비스 지원"],images:[],githubUrl:"",liveUrl:"",imageUrl:"",reflection:["이 프로젝트를 통해 가장 큰 깨달음은 '실시간 미디어 스트림 처리의 복잡성'이었습니다. WebRTC 멀티 스트림 관리에서 스트림 동기화와 DOM 참조 문제를 해결할 때, 단순히 코드 로직만 수정하는 것이 아니라 `nextTick`을 활용한 비동기 DOM 업데이트와 동적 ref 할당까지 전체적인 아키텍처를 이해해야 해결할 수 있다는 것을 배웠습니다. 특히 `createLayout` 함수에서 `videoRefs.value[newItemIndex]`를 참조할 때 발생하는 타이밍 이슈를 해결하기 위해 `await nextTick()`을 사용하여 DOM 업데이트를 보장하는 과정에서, 실시간 시스템에서는 예측하기 어려운 타이밍 이슈들이 발생하므로 전체적인 흐름을 파악하는 것이 중요하다는 것을 깨달았습니다.","또한 '폴링과 소켓 통신의 장단점 분석'을 통해 최적의 통신 방식을 선택하는 과정에서 시스템 아키텍처 설계의 중요성을 배웠습니다. 기존 폴링 방식에서 5초마다 API를 호출하던 것을 Socket.IO 기반 실시간 통신으로 전환하여 네트워크 트래픽을 90% 감소시키고 응답 속도를 50배 개선할 수 있었습니다. 특히 `watch` API를 활용한 즉시 UI 업데이트와 `Object.assign`을 통한 반응형 상태 변경으로 사용자 경험을 크게 향상시킬 수 있었습니다. 이 과정에서 기술적 선택이 비즈니스 성과에 미치는 영향을 직접 경험할 수 있었습니다.","기술적으로는 Vue 3 Composition API의 강력함을 실감했습니다. 복잡한 상태 관리와 생명주기 로직을 더 직관적으로 처리할 수 있어, 실시간 감독 시스템 같은 복잡한 애플리케이션에 매우 적합함을 배웠습니다. 특히 `watch` API를 활용한 즉시 UI 업데이트와 Pinia의 모듈화된 상태 관리로 각 도메인별 상태를 효율적으로 분리 관리할 수 있었습니다. 또한 `vue3-grid-layout-next`를 활용한 동적 레이아웃 시스템에서 `reactive`와 `ref`를 적절히 조합하여 실시간으로 변하는 스트림 상태와 UI를 효율적으로 동기화할 수 있었습니다.","실시간 채팅 시스템 구현 과정에서 '사용자 중심 사고의 중요성'을 깨달았습니다. `SidebarManagerChatList` 컴포넌트에서 `watch`를 활용해 새로운 메시지가 올 때마다 즉시 UI를 업데이트하고, `Object.assign`을 통해 기존 객체를 직접 수정하여 반응형 업데이트를 구현했습니다. 이 과정에서 기술적으로 완벽한 시스템이라도 감독관이 사용하기 어렵다면 의미가 없다는 것을 체감했고, 점진적 개선을 통해 시스템의 안정성과 사용성을 높일 수 있다는 것을 배웠습니다. 특히 실시간 감독 상황에서 직관적인 UI/UX가 얼마나 중요한지 깨달았습니다.","개인적으로는 '근본 원인을 찾아내는 사고방식'을 기르게 되었습니다. WebRTC 스트림 처리에서 발생한 DOM 참조 문제를 해결할 때 표면적인 증상만 보고 해결하려다가 실패했지만, 결국 비동기 처리의 근본 원인을 파악하고 `nextTick` 기반 해결책을 도입하여 완전히 해결할 수 있었습니다. 또한 타임존 처리에서 `dayjs`를 활용한 UTC와 로컬 시간 변환 로직을 구현하면서, 서버와 클라이언트 간의 시간 동기화가 얼마나 중요한지 배웠습니다. 특히 `useDate` 유틸리티에서 `dayjs.utc(dt).local().format(format)`을 통해 서버 UTC 시간을 클라이언트 로컬 시간으로 정확히 변환하는 과정에서, 글로벌 서비스에서 타임존 처리가 얼마나 중요한지 깨달았습니다. 앞으로 어떤 복잡한 문제를 만나더라도 근본 원인을 찾아내는 분석력을 기를 수 있었습니다."]}],I={getCompanies:async()=>(await new Promise(e=>setTimeout(e,100)),z),getProjects:async()=>(await new Promise(e=>setTimeout(e,100)),O),getProject:async e=>(await new Promise(t=>setTimeout(t,100)),O.find(t=>t.id===e)||null),updateCompany:async(e,t)=>(await new Promise(s=>setTimeout(s,200)),console.log(`Company ${e} updated:`,t),z[0]),updateProject:async(e,t)=>(await new Promise(s=>setTimeout(s,200)),console.log(`Project ${e} updated:`,t),O.find(s=>s.id===e)||null),getOtherProjects:async e=>(await new Promise(t=>setTimeout(t,100)),O.filter(t=>t.id!==e))},j={companies:["companies"],projects:["projects"],project:e=>["project",e]},Se=()=>P({queryKey:j.companies,queryFn:I.getCompanies,staleTime:1e3*60*5}),Re=()=>P({queryKey:j.projects,queryFn:I.getProjects,staleTime:1e3*60*5}),Ce=e=>P({queryKey:j.project(e),queryFn:()=>I.getProject(e),enabled:!!e,staleTime:1e3*60*5}),Oe=e=>P({queryKey:[...j.projects,"others",e],queryFn:()=>I.getOtherProjects(e),enabled:!!e,staleTime:1e3*60*5}),Ue=()=>{const e=Se(),t=Re();return{companies:e.data||[],projects:t.data||[],isLoading:e.isLoading||t.isLoading,isError:e.isError||t.isError,error:e.error||t.error}},ke=e=>{const t=Ce(e),s=Oe(e);return{project:t.data,otherProjects:s.data||[],isLoading:t.isLoading||s.isLoading,isError:t.isError||s.isError,error:t.error||s.error}},Pe={default:"bg-gray-100 text-gray-700",blue:"bg-blue-100 text-blue-700",purple:"bg-purple-100 text-purple-700",pink:"bg-pink-100 text-pink-700",indigo:"bg-indigo-100 text-indigo-700",red:"bg-red-100 text-red-700",green:"bg-green-100 text-green-700"},Ie={sm:"px-2 py-1 text-xs",md:"px-3 py-1 text-sm",lg:"px-4 py-2 text-sm"};function Qe({children:e,variant:t="default",size:s="md",className:r="",onClick:i}){const u="rounded-full font-medium hover:scale-110 transform transition-all duration-300",n=Pe[t],g=Ie[s],c=i?"cursor-pointer":"";return o.jsx("span",{className:`${u} ${n} ${g} ${c} ${r}`,onClick:i,children:e})}export{Qe as C,Ee as F,Te as H,ke as a,Ue as u};
//# sourceMappingURL=Chip-CV5Sorm8.js.map
