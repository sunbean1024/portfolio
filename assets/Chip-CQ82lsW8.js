import{S as Z,p as L,b as d,s as E,c as x,n as k,i as D,d as _,t as Y,e as R,f as ee,g as te,h as H,k as z,r as m,l as se,m as ie,u as re,j as a}from"./index-DS8qL9dK.js";var ne=class extends Z{constructor(e,t){super(),this.options=t,this.#s=e,this.#r=null,this.#i=L(),this.bindMethods(),this.setOptions(t)}#s;#e=void 0;#f=void 0;#t=void 0;#o;#u;#i;#r;#m;#h;#d;#a;#c;#n;#p=new Set;bindMethods(){this.refetch=this.refetch.bind(this)}onSubscribe(){this.listeners.size===1&&(this.#e.addObserver(this),K(this.#e,this.options)?this.#l():this.updateResult(),this.#S())}onUnsubscribe(){this.hasListeners()||this.destroy()}shouldFetchOnReconnect(){return V(this.#e,this.options,this.options.refetchOnReconnect)}shouldFetchOnWindowFocus(){return V(this.#e,this.options,this.options.refetchOnWindowFocus)}destroy(){this.listeners=new Set,this.#x(),this.#v(),this.#e.removeObserver(this)}setOptions(e){const t=this.options,s=this.#e;if(this.options=this.#s.defaultQueryOptions(e),this.options.enabled!==void 0&&typeof this.options.enabled!="boolean"&&typeof this.options.enabled!="function"&&typeof d(this.options.enabled,this.#e)!="boolean")throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");this.#P(),this.#e.setOptions(this.options),t._defaulted&&!E(this.options,t)&&this.#s.getQueryCache().notify({type:"observerOptionsUpdated",query:this.#e,observer:this});const i=this.hasListeners();i&&B(this.#e,s,this.options,t)&&this.#l(),this.updateResult(),i&&(this.#e!==s||d(this.options.enabled,this.#e)!==d(t.enabled,this.#e)||x(this.options.staleTime,this.#e)!==x(t.staleTime,this.#e))&&this.#g();const r=this.#b();i&&(this.#e!==s||d(this.options.enabled,this.#e)!==d(t.enabled,this.#e)||r!==this.#n)&&this.#y(r)}getOptimisticResult(e){const t=this.#s.getQueryCache().build(this.#s,e),s=this.createResult(t,e);return ae(this,s)&&(this.#t=s,this.#u=this.options,this.#o=this.#e.state),s}getCurrentResult(){return this.#t}trackResult(e,t){return new Proxy(e,{get:(s,i)=>(this.trackProp(i),t?.(i),i==="promise"&&!this.options.experimental_prefetchInRender&&this.#i.status==="pending"&&this.#i.reject(new Error("experimental_prefetchInRender feature flag is not enabled")),Reflect.get(s,i))})}trackProp(e){this.#p.add(e)}getCurrentQuery(){return this.#e}refetch({...e}={}){return this.fetch({...e})}fetchOptimistic(e){const t=this.#s.defaultQueryOptions(e),s=this.#s.getQueryCache().build(this.#s,t);return s.fetch().then(()=>this.createResult(s,t))}fetch(e){return this.#l({...e,cancelRefetch:e.cancelRefetch??!0}).then(()=>(this.updateResult(),this.#t))}#l(e){this.#P();let t=this.#e.fetch(this.options,e);return e?.throwOnError||(t=t.catch(k)),t}#g(){this.#x();const e=x(this.options.staleTime,this.#e);if(D||this.#t.isStale||!_(e))return;const s=Y(this.#t.dataUpdatedAt,e)+1;this.#a=R.setTimeout(()=>{this.#t.isStale||this.updateResult()},s)}#b(){return(typeof this.options.refetchInterval=="function"?this.options.refetchInterval(this.#e):this.options.refetchInterval)??!1}#y(e){this.#v(),this.#n=e,!(D||d(this.options.enabled,this.#e)===!1||!_(this.#n)||this.#n===0)&&(this.#c=R.setInterval(()=>{(this.options.refetchIntervalInBackground||ee.isFocused())&&this.#l()},this.#n))}#S(){this.#g(),this.#y(this.#b())}#x(){this.#a&&(R.clearTimeout(this.#a),this.#a=void 0)}#v(){this.#c&&(R.clearInterval(this.#c),this.#c=void 0)}createResult(e,t){const s=this.#e,i=this.options,r=this.#t,u=this.#o,n=this.#u,c=e!==s?e.state:this.#f,{state:p}=e;let o={...p},S=!1,l;if(t._optimisticResults){const h=this.hasListeners(),v=!h&&K(e,t),y=h&&B(e,s,t,i);(v||y)&&(o={...o,...te(p.data,e.options)}),t._optimisticResults==="isRestoring"&&(o.fetchStatus="idle")}let{error:M,errorUpdatedAt:N,status:b}=o;l=o.data;let W=!1;if(t.placeholderData!==void 0&&l===void 0&&b==="pending"){let h;r?.isPlaceholderData&&t.placeholderData===n?.placeholderData?(h=r.data,W=!0):h=typeof t.placeholderData=="function"?t.placeholderData(this.#d?.state.data,this.#d):t.placeholderData,h!==void 0&&(b="success",l=H(r?.data,h,t),S=!0)}if(t.select&&l!==void 0&&!W)if(r&&l===u?.data&&t.select===this.#m)l=this.#h;else try{this.#m=t.select,l=t.select(l),l=H(r?.data,l,t),this.#h=l,this.#r=null}catch(h){this.#r=h}this.#r&&(M=this.#r,l=this.#h,N=Date.now(),b="error");const j=o.fetchStatus==="fetching",w=b==="pending",U=b==="error",Q=w&&j,F=l!==void 0,f={status:b,fetchStatus:o.fetchStatus,isPending:w,isSuccess:b==="success",isError:U,isInitialLoading:Q,isLoading:Q,data:l,dataUpdatedAt:o.dataUpdatedAt,error:M,errorUpdatedAt:N,failureCount:o.fetchFailureCount,failureReason:o.fetchFailureReason,errorUpdateCount:o.errorUpdateCount,isFetched:o.dataUpdateCount>0||o.errorUpdateCount>0,isFetchedAfterMount:o.dataUpdateCount>c.dataUpdateCount||o.errorUpdateCount>c.errorUpdateCount,isFetching:j,isRefetching:j&&!w,isLoadingError:U&&!F,isPaused:o.fetchStatus==="paused",isPlaceholderData:S,isRefetchError:U&&F,isStale:A(e,t),refetch:this.refetch,promise:this.#i,isEnabled:d(t.enabled,e)!==!1};if(this.options.experimental_prefetchInRender){const h=P=>{f.status==="error"?P.reject(f.error):f.data!==void 0&&P.resolve(f.data)},v=()=>{const P=this.#i=f.promise=L();h(P)},y=this.#i;switch(y.status){case"pending":e.queryHash===s.queryHash&&h(y);break;case"fulfilled":(f.status==="error"||f.data!==y.value)&&v();break;case"rejected":(f.status!=="error"||f.error!==y.reason)&&v();break}}return f}updateResult(){const e=this.#t,t=this.createResult(this.#e,this.options);if(this.#o=this.#e.state,this.#u=this.options,this.#o.data!==void 0&&(this.#d=this.#e),E(t,e))return;this.#t=t;const s=()=>{if(!e)return!0;const{notifyOnChangeProps:i}=this.options,r=typeof i=="function"?i():i;if(r==="all"||!r&&!this.#p.size)return!0;const u=new Set(r??this.#p);return this.options.throwOnError&&u.add("error"),Object.keys(this.#t).some(n=>{const g=n;return this.#t[g]!==e[g]&&u.has(g)})};this.#R({listeners:s()})}#P(){const e=this.#s.getQueryCache().build(this.#s,this.options);if(e===this.#e)return;const t=this.#e;this.#e=e,this.#f=e.state,this.hasListeners()&&(t?.removeObserver(this),e.addObserver(this))}onQueryUpdate(){this.updateResult(),this.hasListeners()&&this.#S()}#R(e){z.batch(()=>{e.listeners&&this.listeners.forEach(t=>{t(this.#t)}),this.#s.getQueryCache().notify({query:this.#e,type:"observerResultsUpdated"})})}};function oe(e,t){return d(t.enabled,e)!==!1&&e.state.data===void 0&&!(e.state.status==="error"&&t.retryOnMount===!1)}function K(e,t){return oe(e,t)||e.state.data!==void 0&&V(e,t,t.refetchOnMount)}function V(e,t,s){if(d(t.enabled,e)!==!1&&x(t.staleTime,e)!=="static"){const i=typeof s=="function"?s(e):s;return i==="always"||i!==!1&&A(e,t)}return!1}function B(e,t,s,i){return(e!==t||d(i.enabled,e)===!1)&&(!s.suspense||e.state.status!=="error")&&A(e,s)}function A(e,t){return d(t.enabled,e)!==!1&&e.isStaleByTime(x(t.staleTime,e))}function ae(e,t){return!E(e.getCurrentResult(),t)}var J=m.createContext(!1),ce=()=>m.useContext(J);J.Provider;function le(){let e=!1;return{clearReset:()=>{e=!1},reset:()=>{e=!0},isReset:()=>e}}var ue=m.createContext(le()),he=()=>m.useContext(ue),de=(e,t)=>{(e.suspense||e.throwOnError||e.experimental_prefetchInRender)&&(t.isReset()||(e.retryOnMount=!1))},pe=e=>{m.useEffect(()=>{e.clearReset()},[e])},fe=({result:e,errorResetBoundary:t,throwOnError:s,query:i,suspense:r})=>e.isError&&!t.isReset()&&!e.isFetching&&i&&(r&&e.data===void 0||se(s,[e.error,i])),me=e=>{if(e.suspense){const s=r=>r==="static"?r:Math.max(r??1e3,1e3),i=e.staleTime;e.staleTime=typeof i=="function"?(...r)=>s(i(...r)):s(i),typeof e.gcTime=="number"&&(e.gcTime=Math.max(e.gcTime,1e3))}},ge=(e,t)=>e.isLoading&&e.isFetching&&!t,be=(e,t)=>e?.suspense&&t.isPending,q=(e,t,s)=>t.fetchOptimistic(e).catch(()=>{s.clearReset()});function ye(e,t,s){const i=ce(),r=he(),u=ie(),n=u.defaultQueryOptions(e);u.getDefaultOptions().queries?._experimental_beforeQuery?.(n),n._optimisticResults=i?"isRestoring":"optimistic",me(n),de(n,r),pe(r);const g=!u.getQueryCache().get(n.queryHash),[c]=m.useState(()=>new t(u,n)),p=c.getOptimisticResult(n),o=!i&&e.subscribed!==!1;if(m.useSyncExternalStore(m.useCallback(S=>{const l=o?c.subscribe(z.batchCalls(S)):k;return c.updateResult(),l},[c,o]),()=>c.getCurrentResult(),()=>c.getCurrentResult()),m.useEffect(()=>{c.setOptions(n)},[n,c]),be(n,p))throw q(n,c,r);if(fe({result:p,errorResetBoundary:r,throwOnError:n.throwOnError,query:u.getQueryCache().get(n.queryHash),suspense:n.suspense}))throw p.error;return u.getDefaultOptions().queries?._experimental_afterQuery?.(n,p),n.experimental_prefetchInRender&&!D&&ge(p,i)&&(g?q(n,c,r):u.getQueryCache().get(n.queryHash)?.promise)?.catch(k).finally(()=>{c.updateResult()}),n.notifyOnChangeProps?p:c.trackResult(p)}function I(e,t){return ye(e,ne)}function Ee({showBackButton:e=!1,backButtonText:t="돌아가기"}){const s=re();return a.jsx("nav",{className:"bg-white/80 backdrop-blur-sm shadow-sm fixed w-full top-0 z-50",children:a.jsx("div",{className:"max-w-6xl mx-auto px-6 py-4",children:a.jsxs("div",{className:"flex justify-between items-center",children:[a.jsx("button",{onClick:()=>s("/"),className:"font-bold text-2xl text-purple-600 hover:scale-105 transform transition-all duration-300 cursor-pointer",children:"☀️"}),e?a.jsxs("button",{onClick:()=>s("/"),className:"flex items-center space-x-2 text-gray-700 hover:text-purple-600 hover:scale-105 transform transition-all duration-300 cursor-pointer",children:[a.jsx("i",{className:"ri-arrow-left-line text-xl"}),a.jsx("span",{children:t})]}):a.jsxs("div",{className:"hidden md:flex space-x-8",children:[a.jsx("a",{href:"#about",className:"text-gray-700 hover:text-purple-400 transition-all duration-300 hover:scale-105 cursor-pointer",children:"소개"}),a.jsx("a",{href:"#experience",className:"text-gray-700 hover:text-purple-400 transition-all duration-300 hover:scale-105 cursor-pointer",children:"경력"}),a.jsx("a",{href:"#projects",className:"text-gray-700 hover:text-purple-400 transition-all duration-300 hover:scale-105 cursor-pointer",children:"프로젝트"}),a.jsx("a",{href:"#contact",className:"text-gray-700 hover:text-purple-400 transition-all duration-300 hover:scale-105 cursor-pointer",children:"연락처"})]}),a.jsx("button",{className:"md:hidden hover:rotate-180 transition-transform duration-300",children:a.jsx("i",{className:"ri-menu-line text-2xl text-gray-700"})})]})})})}function ke(){return a.jsx("footer",{className:"bg-white py-8 px-6",children:a.jsx("div",{className:"max-w-6xl mx-auto",children:a.jsx("div",{className:"flex flex-col md:flex-row justify-end items-center",children:a.jsx("p",{className:"text-gray-600 mb-4 md:mb-0",children:"© 2025 Park Haebeen"})})})})}const Se="/portfolio/assets/butter-logo-DAKwGqM5.png",xe="/portfolio/assets/jiransoft-logo-CTWEcLyT.png",ve="/portfolio/assets/lgu1-B4A5f2n7.png",G="/portfolio/assets/lgu2-44iI3FAj.png",X="/portfolio/assets/xkeeper1-Due0X3id.png",Pe="/portfolio/assets/xkeeper2-BrietgPG.png",$=[{name:"버터",position:"프론트엔드 개발자 | 대리",period:"2024.03 - 재직중",description:"대규모 멤버십 플랫폼, 브라우저, 실시간 감독 시스템, 온라인 시험 플랫폼 등 아키텍처 설계 및 React/Vue 프론트엔드 개발을 담당했습니다.",logo:Se},{name:"지란지교소프트",position:"프론트엔드 개발자 | 사원",period:"2018.12 - 2022.07",description:"React/TypeScript 도입, Nuxt 리팩토링과 결제 시스템 구현, 실시간 기능 개발 및 CS팀과의 협업을 통한 사용자 경험 개선을 담당했습니다.",logo:xe}],C=[{id:1,title:"LG유플러스 멤버십 통합 서비스",description:"LG유플러스 멤버십 앱 기능을 유플닷컴으로 내재화한 앱 내 웹뷰 기반 통합 서비스로, 네이티브 앱 업데이트 없이도 실시간 기능 배포와 크로스 플랫폼 호환성을 확보한 하이브리드 아키텍처를 구현했습니다.",detailedDescription:"이 프로젝트는 월 10만명 이상의 VIP 고객이 이용하는 대규모 멤버십 플랫폼입니다. VIP콕, 멤버십 사용처, 유플투쁠 이벤트 등 핵심 기능들을 웹뷰로 통합하여 사용자 경험을 일원화했습니다. 특히 iOS WebView 환경에서 발생하는 복잡한 렌더링 이슈를 해결하고, 대기열 시스템을 통해 동시 접속자 급증 시에도 안정적인 서비스를 제공합니다. React Suspense와 TanStack Query를 활용한 상태 관리 최적화, 무한스크롤 페이지네이션 구현, 그리고 VVIP/VIP 차등 정책에 따른 복잡한 사용자 상태 관리까지 전체 프론트엔드 아키텍처를 담당했습니다.",tech:["Next.js 14","React 18","TypeScript","Zustand","TanStack Query","SCSS","NX","Playwright","Storybook"],period:"2024.12 - 진행중",role:"Frontend Developer",challenges:["iOS WebView 백화 현상 해결 (position: sticky GPU 컴포지팅 레이어 이슈)","대기열 시스템 구현 및 무한로딩 현상 해결","VVIP/VIP 차등 정책에 따른 복잡한 사용자 상태 관리","동시 접속자 급증 시 서버 부하 및 사용자 대기 문제","앱 업데이트 없이 실시간 기능 배포를 위한 웹뷰 최적화"],contributions:["iOS WebView 렌더링 이슈 해결로 앱 업데이트 없이도 안정적 서비스 제공","대기열 시스템 구현으로 동시 접속자 급증 시 서버 다운 방지","VIP콕 서비스 개발로 VIP 고객 만족도 향상 및 혜택 이용률 증대","무한스크롤 페이지네이션 최적화로 페이지 로딩 성능 30% 개선","React Suspense 적용으로 서브 페이지 렌더링 단위 분리 및 사용자 경험 개선"],images:[G,ve],githubUrl:"",liveUrl:"",imageUrl:G,reflection:["이 프로젝트를 통해 가장 큰 깨달음은 '문제의 본질을 파악하는 것의 중요성'이었습니다. iOS WebView 백화 현상을 해결할 때, 처음에는 데이터 로딩 문제로 오해하고 글로벌 로딩 컴포넌트를 제거하고 React Suspense를 적용하는 등 여러 시행착오를 겪었습니다. 하지만 결국 브라우저 렌더링 파이프라인 문제라는 근본 원인을 찾아내고, position: sticky 요소의 GPU 컴포지팅 레이어 생성 과정에서 iOS WebKit의 paint invalidation 실패가 원인임을 파악할 수 있었습니다.","또한 '단순한 해결책이 때로는 최고의 해결책'이라는 것을 배웠습니다. 복잡한 CSS 변경이나 DOM 조작 대신 window.scrollTo()라는 단순한 API로 문제를 해결할 수 있었던 것처럼, 과도한 엔지니어링보다는 문제의 핵심을 정확히 파악하는 것이 중요하다는 것을 깨달았습니다. 이는 앞으로 어떤 기술적 도전을 만나더라도 근본 원인을 찾아내는 사고방식을 기르는 데 큰 도움이 되었습니다.","기술적으로는 React/Next.js 생태계의 깊이를 이해하게 되었고, 특히 Suspense와 Error Boundary를 활용한 에러 처리, TanStack Query의 캐싱 전략, 그리고 WebView 환경의 특수성을 고려한 개발 방법론을 익힐 수 있었습니다. 대기열 시스템 구현 과정에서 useEffect 의존성 배열 관리의 중요성과, 무한스크롤에서 메모리 누수 방지를 위한 가비지 컬렉션 최적화 등 실무에서 바로 적용할 수 있는 구체적인 기술들을 습득했습니다.","팀 협업 측면에서는 복잡한 이슈를 체계적으로 분석하고 해결하는 과정에서 동료들과의 소통과 지식 공유의 중요성을 다시 한번 느꼈습니다. 특히 iOS WebView 이슈 해결 과정에서 팀원들과 함께 문제를 분석하고, 다양한 접근 방법을 시도해보며 최종 해결책을 찾아가는 과정에서 팀워크의 가치를 깊이 체감했습니다. 앞으로도 이런 협업을 통해 더 나은 솔루션을 만들어갈 수 있을 것 같습니다."]},{id:2,title:"고사장 브라우저 (시험 감독용 보안 브라우저)",description:"시험 부정행위 방지를 위한 보안 브라우저로, 운영체제 레벨 보안 모듈을 통합하여 키보드/마우스 입력 차단, 화면 캡처 방지, 클립보드 제어 등 다중 보안 계층을 구현한 Electron 기반 데스크톱 애플리케이션입니다.",detailedDescription:"이 프로젝트는 온라인 시험 환경에서 응시자의 부정행위를 방지하기 위한 보안 브라우저 개발입니다. Rust 기반 proctor-internal 모듈을 Electron에 통합하여 시스템 레벨 보안 기능을 구현했으며, WebContents → WebView 마이그레이션을 통해 UI 가려짐 문제를 해결했습니다. 멀티 탭 시스템과 URL 스킴 처리, 실시간 상태 모니터링 기능을 구현하여 시험 감독자가 원격으로 브라우저를 제어할 수 있도록 했습니다. 특히 보안 모듈 충돌 방지를 위한 뮤텍스 기반 동기화 시스템과 크로스 플랫폼 호환성을 위한 각 OS별 보안 API 통합까지 전체 아키텍처를 담당했습니다.",tech:["Electron 26","React 18","TypeScript","Recoil","Rust","Node.js","Express.js","SCSS","Webpack 5","Electron Builder"],period:"2024.03 ~ 2025.08",role:"Full-stack Developer",challenges:["WebContents 사용 시 브라우저 UI가 웹 콘텐츠에 가려지는 문제","보안 모듈 간 충돌로 인한 시스템 불안정성","크로스 플랫폼 환경에서 각 OS별 보안 API 차이점 해결","Windows 키 차단 기능이 제대로 작동하지 않는 버그","멀티 탭 환경에서 메모리 사용량 최적화","Rust 기반 네이티브 모듈을 Electron에 안전하게 통합"],contributions:["WebView 마이그레이션으로 UI 가려짐 문제 해결 및 사용자 경험 100% 개선","뮤텍스 기반 동기화 시스템으로 보안 모듈 충돌 방지 및 시스템 안정성 확보","멀티 탭 최적화로 메모리 사용량 60% 감소 (포커스된 탭만 활성화)","URL 스킴 처리 시스템 구현으로 외부에서 브라우저 원격 제어 가능","실시간 상태 모니터링 시스템으로 웹캠, 화면공유, 스마트폰 연결 상태 표시","크로스 플랫폼 호환성 확보로 macOS/Windows/Linux 지원"],images:[],githubUrl:"",liveUrl:"",imageUrl:"",reflection:["이 프로젝트를 통해 가장 큰 깨달음은 '시스템 전체를 이해하는 것의 중요성'이었습니다. Windows 키 차단 버그를 해결할 때, 처음에는 코드 로직만 수정하려고 했지만 결국 package.json의 의존성 관리와 네이티브 모듈 빌드 과정까지 전체적으로 이해해야 해결할 수 있다는 것을 배웠습니다. 단순히 문제가 발생한 부분만 수정하는 것이 아니라 전체 시스템의 연관성을 파악하는 것이 중요하다는 것을 깨달았습니다.","또한 '보안과 사용성의 균형'을 맞추는 것이 얼마나 어려운지 체감했습니다. 강력한 보안 기능을 구현하면서도 직관적인 사용자 경험을 제공하기 위해 WebContents에서 WebView로 아키텍처를 변경하는 등 여러 시행착오를 겪었습니다. 이 과정에서 사용자 중심의 기술적 의사결정이 얼마나 중요한지 배웠습니다.","기술적으로는 Electron 생태계의 깊이를 이해하게 되었고, 특히 네이티브 모듈 통합, IPC 통신, 크로스 플랫폼 개발의 복잡성을 경험했습니다. Rust와 TypeScript를 함께 사용하면서 각 언어의 장점을 살린 하이브리드 개발 방법론을 익힐 수 있었고, Inspector 패턴을 활용한 확장 가능한 보안 모듈 아키텍처 설계 능력을 기를 수 있었습니다.","개인적으로는 '근본 원인을 찾아내는 사고방식'을 기르게 되었습니다. 보안 모듈 충돌 문제를 해결할 때 표면적인 증상만 보고 해결하려다가 실패했지만, 결국 동시성 프로그래밍의 근본 원인을 파악하고 뮤텍스 기반 해결책을 도입하여 완전히 해결할 수 있었습니다. 앞으로 어떤 복잡한 문제를 만나더라도 근본 원인을 찾아내는 분석력을 기를 수 있었습니다."]},{id:3,title:"고사장 프로터 웹 시스템 (실시간 감독 플랫폼)",description:"온라인 시험 환경에서 감독관이 응시자를 실시간으로 모니터링할 수 있는 웹 기반 감독 시스템입니다. WebRTC 기반 멀티 스트림 관리, Socket.IO 실시간 통신, 동적 그리드 레이아웃을 통해 PC와 모바일 기기에서 동시에 전송되는 비디오/오디오 스트림을 효율적으로 처리하며, 실시간 채팅과 상태 동기화를 제공합니다.",detailedDescription:"이 프로젝트는 코로나19로 인한 온라인 시험 환경 확산에 따라 기존 오프라인 감독 시스템을 웹 기반 실시간 감독 시스템으로 전환하는 프로젝트입니다. Vue 3 Composition API와 TypeScript를 활용하여 WebRTC 기반 멀티 스트림 실시간 감독 시스템을 개발했으며, vue3-grid-layout-next를 통한 동적 화면 배치와 실시간 레이아웃 조정 기능을 구현했습니다. 폴링 방식에서 Socket.IO 기반 실시간 통신으로 전환하여 네트워크 트래픽을 90% 감소시키고 응답 속도를 50배 개선했습니다. Pinia를 활용한 전역 상태 관리, 실시간 채팅 및 알림 시스템을 구현하여 감독 효율성을 크게 향상시켰습니다.",tech:["Vue 3","TypeScript","Pinia","Socket.IO","WebRTC","PrimeVue","SCSS","Vite","Docker","Nginx"],period:"2024.03 ~ 2025.08",role:"Frontend Developer",challenges:["WebRTC 멀티 스트림 동기화 및 DOM 참조 문제","폴링 방식의 서버 부하 증가 및 실시간성 부족","동적 그리드 레이아웃에서 비동기 처리로 인한 UI 업데이트 지연","실시간 상태 동기화에서 발생하는 데이터 불일치","타임존 처리로 인한 서버 UTC 시간과 클라이언트 로컬 시간 불일치","Socket.IO 연결 상태 관리 및 재연결 처리"],contributions:["WebRTC 기반 멀티 스트림 실시간 감독 시스템 개발 (PC/모바일 동시 지원)","폴링에서 Socket.IO 기반 실시간 통신으로 전환하여 네트워크 트래픽 90% 감소","vue3-grid-layout-next를 활용한 동적 화면 배치 및 실시간 레이아웃 조정 구현","Pinia를 활용한 전역 상태 관리로 인증, 시험, 스트림 상태 동기화 최적화","실시간 채팅, 알림, 상태 변경을 통한 감독 효율성 향상 및 사용자 경험 개선","타임존 처리 시스템 구현으로 글로벌 서비스 지원"],images:[],githubUrl:"",liveUrl:"",imageUrl:"",reflection:["이 프로젝트를 통해 가장 큰 깨달음은 '실시간 미디어 스트림 처리의 복잡성'이었습니다. WebRTC 멀티 스트림 관리에서 스트림 동기화와 DOM 참조 문제를 해결할 때, 단순히 코드 로직만 수정하는 것이 아니라 `nextTick`을 활용한 비동기 DOM 업데이트와 동적 ref 할당까지 전체적인 아키텍처를 이해해야 해결할 수 있다는 것을 배웠습니다. 특히 `createLayout` 함수에서 `videoRefs.value[newItemIndex]`를 참조할 때 발생하는 타이밍 이슈를 해결하기 위해 `await nextTick()`을 사용하여 DOM 업데이트를 보장하는 과정에서, 실시간 시스템에서는 예측하기 어려운 타이밍 이슈들이 발생하므로 전체적인 흐름을 파악하는 것이 중요하다는 것을 깨달았습니다.","또한 '폴링과 소켓 통신의 장단점 분석'을 통해 최적의 통신 방식을 선택하는 과정에서 시스템 아키텍처 설계의 중요성을 배웠습니다. 기존 폴링 방식에서 5초마다 API를 호출하던 것을 Socket.IO 기반 실시간 통신으로 전환하여 네트워크 트래픽을 90% 감소시키고 응답 속도를 50배 개선할 수 있었습니다. 특히 `watch` API를 활용한 즉시 UI 업데이트와 `Object.assign`을 통한 반응형 상태 변경으로 사용자 경험을 크게 향상시킬 수 있었습니다. 이 과정에서 기술적 선택이 비즈니스 성과에 미치는 영향을 직접 경험할 수 있었습니다.","기술적으로는 Vue 3 Composition API의 강력함을 실감했습니다. 복잡한 상태 관리와 생명주기 로직을 더 직관적으로 처리할 수 있어, 실시간 감독 시스템 같은 복잡한 애플리케이션에 매우 적합함을 배웠습니다. 특히 `watch` API를 활용한 즉시 UI 업데이트와 Pinia의 모듈화된 상태 관리로 각 도메인별 상태를 효율적으로 분리 관리할 수 있었습니다. 또한 `vue3-grid-layout-next`를 활용한 동적 레이아웃 시스템에서 `reactive`와 `ref`를 적절히 조합하여 실시간으로 변하는 스트림 상태와 UI를 효율적으로 동기화할 수 있었습니다.","실시간 채팅 시스템 구현 과정에서 '사용자 중심 사고의 중요성'을 깨달았습니다. `SidebarManagerChatList` 컴포넌트에서 `watch`를 활용해 새로운 메시지가 올 때마다 즉시 UI를 업데이트하고, `Object.assign`을 통해 기존 객체를 직접 수정하여 반응형 업데이트를 구현했습니다. 이 과정에서 기술적으로 완벽한 시스템이라도 감독관이 사용하기 어렵다면 의미가 없다는 것을 체감했고, 점진적 개선을 통해 시스템의 안정성과 사용성을 높일 수 있다는 것을 배웠습니다. 특히 실시간 감독 상황에서 직관적인 UI/UX가 얼마나 중요한지 깨달았습니다.","개인적으로는 '근본 원인을 찾아내는 사고방식'을 기르게 되었습니다. WebRTC 스트림 처리에서 발생한 DOM 참조 문제를 해결할 때 표면적인 증상만 보고 해결하려다가 실패했지만, 결국 비동기 처리의 근본 원인을 파악하고 `nextTick` 기반 해결책을 도입하여 완전히 해결할 수 있었습니다. 또한 타임존 처리에서 `dayjs`를 활용한 UTC와 로컬 시간 변환 로직을 구현하면서, 서버와 클라이언트 간의 시간 동기화가 얼마나 중요한지 배웠습니다. 특히 `useDate` 유틸리티에서 `dayjs.utc(dt).local().format(format)`을 통해 서버 UTC 시간을 클라이언트 로컬 시간으로 정확히 변환하는 과정에서, 글로벌 서비스에서 타임존 처리가 얼마나 중요한지 깨달았습니다. 앞으로 어떤 복잡한 문제를 만나더라도 근본 원인을 찾아내는 분석력을 기를 수 있었습니다."]},{id:4,title:"온라인 시험 플랫폼 (ONTP) - 응시자 웹 시스템",description:"실시간 감시(Proctoring) 시스템을 통한 온라인 시험 플랫폼으로, WebRTC 기반 화면 공유와 Socket.io를 활용한 실시간 통신을 구현했습니다. 8가지 문항 유형을 지원하며 글로벌 시험 환경을 위한 타임존 처리와 크로스 플랫폼 호환성을 확보한 Vue 3 기반 하이브리드 웹 애플리케이션입니다.",detailedDescription:"이 프로젝트는 코로나19로 인한 비대면 시험 환경의 급증에 대응하여 개발된 대규모 온라인 시험 플랫폼입니다. 월 수만 명의 응시자가 이용하는 시스템으로, 실시간 감시를 통한 부정행위 방지와 다양한 문항 유형 지원이 핵심입니다. Vue 3 Composition API와 Pinia를 활용한 상태 관리, Proctor SDK v3를 통한 WebRTC 기반 실시간 감시, Socket.io를 통한 실시간 채팅 시스템을 구현했습니다. 특히 iOS WebKit 환경에서의 타이머 동기화 문제, 소켓 통신의 중복 API 호출 이슈, 그리고 글로벌 시험을 위한 타임존 처리 등 복잡한 기술적 도전들을 해결하며 전체 프론트엔드 아키텍처를 담당했습니다.",tech:["Vue 3","TypeScript","Pinia","WebRTC","Socket.io","SCSS","Vite 5","Proctor SDK v3","Face-api.js"],period:"2024.03 ~ 2025.08",role:"Frontend Developer (유지보수 및 기능 개선)",challenges:["실시간 타이머 동기화 문제로 인한 '잔여 시간이 실제와 다르게 표시'되는 이슈","소켓 통신에서 채팅 열기 + 메시지 수신 시 API 중복 호출 문제","iOS WebKit 환경에서의 브라우저 호환성 및 렌더링 이슈","Proctor SDK v3 통합 시 WebRTC 연결 실패 및 오류 처리 복잡성","글로벌 시험 환경을 위한 타임존 처리 및 크로스 플랫폼 호환성"],contributions:["실시간 타이머 동기화 시스템 구축으로 서버-클라이언트 시간 불일치 문제 해결","소켓 통신 최적화로 API 중복 호출 방지 및 성능 개선","30개 이상 컴포넌트에 걸친 포괄적 로깅 시스템 구축으로 디버깅 효율성 향상","디바이스 정보 수집 시스템 구현으로 다양한 모바일 환경 지원","Proctor SDK 오류 처리 강화로 WebRTC 연결 안정성 40% 개선"],images:[],githubUrl:"",liveUrl:"",imageUrl:"",reflection:["이 프로젝트를 통해 가장 큰 깨달음은 '유지보수 작업의 중요성과 복잡성'이었습니다. 처음에는 단순한 버그 수정으로 생각했던 타이머 동기화 문제가 실제로는 서버와 클라이언트 간의 시간 동기화 메커니즘 전체를 재검토해야 하는 복잡한 이슈였습니다. 1초마다 서버 시간을 폴링하는 시스템을 구축하면서 실시간 시스템의 예측하기 어려운 특성을 깊이 이해하게 되었습니다.","또한 '소켓 통신의 중복 API 호출 문제'를 해결하면서 이벤트 기반 아키텍처에서 발생할 수 있는 부작용들을 경험했습니다. 단순히 API 호출을 제거하는 것이 아니라, 채팅 열기와 소켓 메시지 수신이라는 두 가지 이벤트가 언제 발생하는지 정확히 파악하고, innerVisible.value 조건을 추가하여 적절한 시점에만 API가 호출되도록 수정했습니다. 이 과정에서 '이벤트 흐름의 정확한 이해'가 얼마나 중요한지 깨달았습니다.","기술적으로는 Vue 3 Composition API의 장점을 실무에서 체감할 수 있었습니다. 특히 watch 함수의 복잡한 의존성 관리와 nextTick을 활용한 DOM 업데이트 타이밍 제어 등, 프레임워크의 세부 기능들을 깊이 이해하게 되었습니다. 또한 WebRTC와 Socket.io를 조합한 실시간 통신 시스템에서 발생하는 네트워크 불안정성과 브라우저 호환성 문제를 해결하면서, 크로스 플랫폼 개발의 어려움과 해결 방법을 학습할 수 있었습니다.","팀 협업 측면에서는 기존 코드베이스를 이해하고 개선하는 과정에서 '레거시 코드와의 소통'의 중요성을 느꼈습니다. 30개 이상의 컴포넌트에 로깅 시스템을 추가하면서 기존 개발자들의 의도를 파악하고, 최소한의 변경으로 최대한의 효과를 얻는 방법을 고민했습니다. 특히 Proctor SDK 업데이트 과정에서 41개 파일을 수정하면서, 외부 라이브러리와의 통합 시 발생하는 복잡성을 체험하고 이를 체계적으로 관리하는 방법을 익혔습니다."]},{id:5,title:"온라인 시험 감독 시스템",description:"기업 관리자가 시험과 응시자 환경을 관리하는 서비스로, 실시간 감독 영상 모니터링과 멀티 비디오 동기화 플레이어를 통해 시험의 투명성과 공정성을 보장하는 시스템입니다.",detailedDescription:"이 프로젝트는 온라인 시험의 감독 과정을 디지털화하여 관리자가 PC화면, 정면감독, 주변감독 3개 카메라의 영상을 실시간으로 모니터링할 수 있는 시스템입니다. 가장 핵심적인 기능은 서로 다른 시작/종료 시간을 가진 여러 비디오 스트림을 하나의 타임라인으로 통합하여 동기화 재생하는 것입니다. Vue 3 Composition API와 HTML5 Video API를 활용하여 복잡한 시간축 계산과 상태 관리를 구현했으며, 감독 메모와 채팅 이벤트를 타임라인에 시각적으로 표시하고 해당 시점으로 즉시 이동할 수 있는 기능을 제공합니다. 또한 응시자의 디바이스/네트워크/리소스 상태를 실시간으로 모니터링하여 시험 환경의 안정성을 보장합니다.",tech:["Vue 3","TypeScript","HTML5 Video API","Moment.js","SCSS","Vite","PrimeVue"],period:"2024.03 ~ 2025.08",role:"Frontend Developer",challenges:["3개 독립 비디오 스트림의 실시간 동기화 구현","서로 다른 시작/종료 시간을 가진 비디오들의 타임라인 통합","복잡한 시간축 계산 로직으로 정확한 재생 위치 제어","대용량 비디오 스트림의 메모리 효율적 관리","실시간 이벤트 마킹과 타임라인 연동","iOS WebView 환경에서의 비디오 재생 최적화"],contributions:["멀티 비디오 동기화 플레이어 개발로 감독 효율성 50% 향상","실시간 타임라인 이벤트 마킹으로 감독 메모/채팅 추적 정확도 개선","복잡한 시간축 계산 알고리즘 구현으로 정밀한 비디오 제어 가능","Vite 기반 빌드 최적화로 개발 환경 성능 40% 개선","반응형 UI 구현으로 다양한 디바이스에서 안정적인 감독 환경 제공","메모리 효율적인 비디오 참조 관리로 장시간 사용 시 안정성 확보"],images:[],githubUrl:"",liveUrl:"",imageUrl:"",reflection:["이 프로젝트를 통해 가장 큰 깨달음은 '복잡한 멀티미디어 동기화의 기술적 도전'이었습니다. 3개의 독립적인 비디오 스트림을 하나의 컨트롤러로 관리하면서, 각 비디오의 시작/종료 시간이 다르다는 점이 가장 큰 기술적 난제였습니다. 처음에는 단순히 currentTime을 동기화하는 것으로 충분할 것이라고 생각했지만, 실제로는 각 비디오의 절대 시간을 기준으로 상대 시간을 계산하는 복잡한 알고리즘이 필요했습니다.","특히 '시간축 통합의 복잡성'을 깊이 이해하게 되었습니다. 서로 다른 시점에 녹화된 비디오들을 하나의 타임라인으로 통합하려면, 각 비디오의 시작 시간을 기준으로 한 상대적 시간 계산이 핵심이었습니다. Moment.js를 활용한 Unix 타임스탬프 계산과 비디오의 duration을 고려한 정확한 재생 위치 제어 로직을 구현하는 과정에서 시간 기반 데이터 처리의 깊이를 배웠습니다.","기술적으로는 Vue 3 Composition API의 진정한 가치를 체감했습니다. 복잡한 상태 관리와 비디오 참조 관리에서 reactive와 ref의 차이점, 그리고 nextTick을 활용한 DOM 업데이트 최적화 등 실무에서 바로 적용할 수 있는 구체적인 기술들을 습득했습니다. 또한 HTML5 Video API의 제약사항과 브라우저별 차이점을 이해하게 되었고, 특히 iOS WebView 환경에서의 비디오 재생 최적화 경험은 매우 소중했습니다.","사용자 경험 측면에서는 '복잡한 기술 뒤에 숨은 직관적 인터페이스'의 중요성을 깨달았습니다. 기술적으로는 매우 복잡한 동기화 로직이지만, 사용자에게는 단순한 슬라이더 조작으로 모든 비디오를 제어할 수 있도록 만드는 것이 핵심이었습니다. 또한 실시간 이벤트 마킹을 통해 감독자가 특정 시점의 상황을 빠르게 파악할 수 있도록 하는 UX 설계 경험을 쌓을 수 있었습니다.","팀 협업 측면에서는 '기술적 복잡성을 팀원들과 공유하는 방법'을 배웠습니다. 멀티미디어 동기화라는 비교적 생소한 기술 영역을 팀원들과 함께 분석하고 해결해가는 과정에서, 복잡한 기술을 이해하기 쉽게 설명하고 공유하는 소통 능력의 중요성을 깨달았습니다. 앞으로도 이런 협업을 통해 더 나은 솔루션을 만들어갈 수 있을 것 같습니다."]},{id:6,title:"통합운영시스템",description:"지란지교소프트의 오피스웨어 및 관련 제품들을 관리하는 사이트로, 메신저 봇 관리, 메시지 용량 통계, 사용자 및 IP 관리, 결제 취소 기능 등을 제공하는 시스템입니다.",detailedDescription:"이 프로젝트는 회사 내부에서 사용하는 통합 관리 시스템으로, 기획부터 디자인, 화면 구성까지 팀원들과 협업하여 개발했습니다. next-auth 기반 인증, Ant Design UI 구성, axios를 통한 서버 통신 등을 구현했습니다. 팀 내 역할 변화로 인해 서버와 프론트엔드 구분이 모호해진 상황에서 서버 환경 세팅 및 로컬 로그 분석을 통해 문제를 해결하며 서버 이해도를 넓힐 수 있었습니다.",tech:["React","TypeScript","Ant Design","Next-Auth","Axios","Git","Jira"],period:"2022.04 ~ 2022.07",role:"Frontend Developer",challenges:["React와 TypeScript를 처음 도입하며 프로젝트 초기 세팅 및 적용","서버/프론트 구분 없는 팀 환경에서 유연하게 대응","next-auth를 활용한 인증 처리","Ant Design을 이용한 UI/UX 구성","서버 로그 기반 디버깅 및 문제 해결"],contributions:["프론트엔드 주요 기능 개발 (로그인/로그아웃, UI 구성)","Ant Design 기반 사용자 친화적 UI/UX 구현","서버 통신 및 로컬 환경 로그 분석을 통한 문제 해결","팀 내 의사소통 및 협업 과정에서 의견 수용 능력 향상"],images:[],githubUrl:"",liveUrl:"",imageUrl:"",reflection:["React와 TypeScript를 처음 사용한 프로젝트로, 실무 적용 경험을 쌓을 수 있었습니다.","팀원들과 기획, 디자인, 화면 구성까지 논의하며 협업 과정의 중요성을 배웠습니다.","서버/프론트 구분이 없는 환경에서 서버 환경 세팅과 로그 분석을 통해 문제 해결 능력을 키웠습니다.","PHP 서버 코드를 직접 작성하지는 않았지만, 서버 측 동작을 이해하고 코드 전반을 넓게 바라보는 시야를 얻었습니다."]},{id:7,title:"Xkeeper 홈페이지 리팩토링",description:"엑스키퍼 제품 홈페이지를 Nuxt 기반으로 리팩토링하여 기능 소개, 자녀 사용 제어 및 보고서 제공, 구매 기능 등을 포함한 사용자 친화적인 웹사이트를 개발했습니다.",detailedDescription:"이 프로젝트는 기존에 존재하던 Xkeeper 홈페이지를 Nuxt 기반으로 리팩토링한 작업입니다. 주요 기능으로는 자녀의 PC/모바일 사용 시간 제어, 사용 기록 리포트 제공, 위치 서비스(구글맵 & 카카오맵 API), 실시간 데스크탑 화면 캡쳐(socket.io), 이니시스 결제, 구글 리캡챠 보안 강화 등이 있습니다. 프론트엔드 전반을 담당하며 사용자 경험 향상에 집중하였습니다.",tech:["Nuxt","Sass","JavaScript","Axios","Lodash","PHP","Git","Sonar","Sentry","Jira"],period:"2020.01 ~ 2022.04",role:"Frontend Developer",challenges:["기존 홈페이지를 Nuxt 기반으로 리팩토링","구글맵과 카카오 지도 API를 조합해 위치 서비스 구현","socket.io를 활용한 실시간 데스크탑 화면 캡쳐 기능","이니시스 결제를 통한 구매 기능 구현","구글 리캡챠 기반 로그인 보안 강화","CS팀과 협업을 통해 고객 피드백을 직접 반영"],contributions:["홈페이지 프론트엔드 전체 리팩토링 (90% 이상 기여)","구글맵 API와 카카오 지도 API를 결합하여 직관적인 위치 서비스 제공","socket.io 기반 실시간 자녀 PC 화면 캡쳐 기능 개발","이니시스 결제 프로세스 구현으로 상용 결제 경험 확보","구글 리캡챠 적용으로 보안 강화","사용자 경험 개선을 위해 CS팀과 협업하여 고객 피드백 반영"],images:[X,Pe],githubUrl:"",liveUrl:"https://xkeeper.com/",imageUrl:X,reflection:["처음으로 이니시스 결제 기능을 개발하며 결제 프로세스에 대한 이해를 넓혔습니다.","기존에는 내부 시스템 개발 위주였지만, 실제 외부 사용자들이 이용하는 홈페이지를 개발하면서 사용자와 더 가까워졌다는 보람을 느꼈습니다.","홈페이지 오류 발생 시 고객센터로 직접 문의가 들어오기 때문에 CS팀과 협업하며 고객들의 생생한 목소리를 들을 수 있었고, 이를 바탕으로 더 나은 사용자 경험을 제공할 수 있었습니다."]}],T={getCompanies:async()=>(await new Promise(e=>setTimeout(e,100)),$),getProjects:async()=>(await new Promise(e=>setTimeout(e,100)),C),getProject:async e=>(await new Promise(t=>setTimeout(t,100)),C.find(t=>t.id===e)||null),updateCompany:async(e,t)=>(await new Promise(s=>setTimeout(s,200)),console.log(`Company ${e} updated:`,t),$[0]),updateProject:async(e,t)=>(await new Promise(s=>setTimeout(s,200)),console.log(`Project ${e} updated:`,t),C.find(s=>s.id===e)||null),getOtherProjects:async e=>(await new Promise(t=>setTimeout(t,100)),C.filter(t=>t.id!==e))},O={companies:["companies"],projects:["projects"],project:e=>["project",e]},Re=()=>I({queryKey:O.companies,queryFn:T.getCompanies,staleTime:1e3*60*5}),Ce=()=>I({queryKey:O.projects,queryFn:T.getProjects,staleTime:1e3*60*5}),Ie=e=>I({queryKey:O.project(e),queryFn:()=>T.getProject(e),enabled:!!e,staleTime:1e3*60*5}),Te=e=>I({queryKey:[...O.projects,"others",e],queryFn:()=>T.getOtherProjects(e),enabled:!!e,staleTime:1e3*60*5}),De=()=>{const e=Re(),t=Ce();return{companies:e.data||[],projects:t.data||[],isLoading:e.isLoading||t.isLoading,isError:e.isError||t.isError,error:e.error||t.error}},Ve=e=>{const t=Ie(e),s=Te(e);return{project:t.data,otherProjects:s.data||[],isLoading:t.isLoading||s.isLoading,isError:t.isError||s.isError,error:t.error||s.error}},Oe={default:"bg-gray-100 text-gray-700",blue:"bg-blue-100 text-blue-700",purple:"bg-purple-100 text-purple-700",pink:"bg-pink-100 text-pink-700",indigo:"bg-indigo-100 text-indigo-700",red:"bg-red-100 text-red-700",green:"bg-green-100 text-green-700"},je={sm:"px-2 py-1 text-xs",md:"px-3 py-1 text-sm",lg:"px-4 py-2 text-sm"};function Ae({children:e,variant:t="default",size:s="md",className:i="",onClick:r}){const u="rounded-full font-medium hover:scale-110 transform transition-all duration-300",n=Oe[t],g=je[s],c=r?"cursor-pointer":"";return a.jsx("span",{className:`${u} ${n} ${g} ${c} ${i}`,onClick:r,children:e})}export{Ae as C,ke as F,Ee as H,Ve as a,De as u};
//# sourceMappingURL=Chip-CQ82lsW8.js.map
