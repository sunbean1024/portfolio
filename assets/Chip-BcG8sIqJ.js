import{S as Z,p as L,b as d,s as U,c as v,n as D,i as k,d as _,t as Y,e as P,f as ee,g as te,h as H,k as X,r as m,l as se,m as re,u as ie,j as a}from"./index-BTPONLqS.js";var ne=class extends Z{constructor(e,t){super(),this.options=t,this.#s=e,this.#i=null,this.#r=L(),this.bindMethods(),this.setOptions(t)}#s;#e=void 0;#f=void 0;#t=void 0;#o;#u;#r;#i;#m;#h;#d;#a;#c;#n;#p=new Set;bindMethods(){this.refetch=this.refetch.bind(this)}onSubscribe(){this.listeners.size===1&&(this.#e.addObserver(this),K(this.#e,this.options)?this.#l():this.updateResult(),this.#x())}onUnsubscribe(){this.hasListeners()||this.destroy()}shouldFetchOnReconnect(){return M(this.#e,this.options,this.options.refetchOnReconnect)}shouldFetchOnWindowFocus(){return M(this.#e,this.options,this.options.refetchOnWindowFocus)}destroy(){this.listeners=new Set,this.#v(),this.#S(),this.#e.removeObserver(this)}setOptions(e){const t=this.options,s=this.#e;if(this.options=this.#s.defaultQueryOptions(e),this.options.enabled!==void 0&&typeof this.options.enabled!="boolean"&&typeof this.options.enabled!="function"&&typeof d(this.options.enabled,this.#e)!="boolean")throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");this.#R(),this.#e.setOptions(this.options),t._defaulted&&!U(this.options,t)&&this.#s.getQueryCache().notify({type:"observerOptionsUpdated",query:this.#e,observer:this});const r=this.hasListeners();r&&B(this.#e,s,this.options,t)&&this.#l(),this.updateResult(),r&&(this.#e!==s||d(this.options.enabled,this.#e)!==d(t.enabled,this.#e)||v(this.options.staleTime,this.#e)!==v(t.staleTime,this.#e))&&this.#g();const i=this.#b();r&&(this.#e!==s||d(this.options.enabled,this.#e)!==d(t.enabled,this.#e)||i!==this.#n)&&this.#y(i)}getOptimisticResult(e){const t=this.#s.getQueryCache().build(this.#s,e),s=this.createResult(t,e);return ae(this,s)&&(this.#t=s,this.#u=this.options,this.#o=this.#e.state),s}getCurrentResult(){return this.#t}trackResult(e,t){return new Proxy(e,{get:(s,r)=>(this.trackProp(r),t?.(r),r==="promise"&&!this.options.experimental_prefetchInRender&&this.#r.status==="pending"&&this.#r.reject(new Error("experimental_prefetchInRender feature flag is not enabled")),Reflect.get(s,r))})}trackProp(e){this.#p.add(e)}getCurrentQuery(){return this.#e}refetch({...e}={}){return this.fetch({...e})}fetchOptimistic(e){const t=this.#s.defaultQueryOptions(e),s=this.#s.getQueryCache().build(this.#s,t);return s.fetch().then(()=>this.createResult(s,t))}fetch(e){return this.#l({...e,cancelRefetch:e.cancelRefetch??!0}).then(()=>(this.updateResult(),this.#t))}#l(e){this.#R();let t=this.#e.fetch(this.options,e);return e?.throwOnError||(t=t.catch(D)),t}#g(){this.#v();const e=v(this.options.staleTime,this.#e);if(k||this.#t.isStale||!_(e))return;const s=Y(this.#t.dataUpdatedAt,e)+1;this.#a=P.setTimeout(()=>{this.#t.isStale||this.updateResult()},s)}#b(){return(typeof this.options.refetchInterval=="function"?this.options.refetchInterval(this.#e):this.options.refetchInterval)??!1}#y(e){this.#S(),this.#n=e,!(k||d(this.options.enabled,this.#e)===!1||!_(this.#n)||this.#n===0)&&(this.#c=P.setInterval(()=>{(this.options.refetchIntervalInBackground||ee.isFocused())&&this.#l()},this.#n))}#x(){this.#g(),this.#y(this.#b())}#v(){this.#a&&(P.clearTimeout(this.#a),this.#a=void 0)}#S(){this.#c&&(P.clearInterval(this.#c),this.#c=void 0)}createResult(e,t){const s=this.#e,r=this.options,i=this.#t,u=this.#o,n=this.#u,c=e!==s?e.state:this.#f,{state:p}=e;let o={...p},x=!1,l;if(t._optimisticResults){const h=this.hasListeners(),S=!h&&K(e,t),y=h&&B(e,s,t,r);(S||y)&&(o={...o,...te(p.data,e.options)}),t._optimisticResults==="isRestoring"&&(o.fetchStatus="idle")}let{error:A,errorUpdatedAt:V,status:b}=o;l=o.data;let Q=!1;if(t.placeholderData!==void 0&&l===void 0&&b==="pending"){let h;i?.isPlaceholderData&&t.placeholderData===n?.placeholderData?(h=i.data,Q=!0):h=typeof t.placeholderData=="function"?t.placeholderData(this.#d?.state.data,this.#d):t.placeholderData,h!==void 0&&(b="success",l=H(i?.data,h,t),x=!0)}if(t.select&&l!==void 0&&!Q)if(i&&l===u?.data&&t.select===this.#m)l=this.#h;else try{this.#m=t.select,l=t.select(l),l=H(i?.data,l,t),this.#h=l,this.#i=null}catch(h){this.#i=h}this.#i&&(A=this.#i,l=this.#h,V=Date.now(),b="error");const j=o.fetchStatus==="fetching",w=b==="pending",E=b==="error",F=w&&j,W=l!==void 0,f={status:b,fetchStatus:o.fetchStatus,isPending:w,isSuccess:b==="success",isError:E,isInitialLoading:F,isLoading:F,data:l,dataUpdatedAt:o.dataUpdatedAt,error:A,errorUpdatedAt:V,failureCount:o.fetchFailureCount,failureReason:o.fetchFailureReason,errorUpdateCount:o.errorUpdateCount,isFetched:o.dataUpdateCount>0||o.errorUpdateCount>0,isFetchedAfterMount:o.dataUpdateCount>c.dataUpdateCount||o.errorUpdateCount>c.errorUpdateCount,isFetching:j,isRefetching:j&&!w,isLoadingError:E&&!W,isPaused:o.fetchStatus==="paused",isPlaceholderData:x,isRefetchError:E&&W,isStale:N(e,t),refetch:this.refetch,promise:this.#r,isEnabled:d(t.enabled,e)!==!1};if(this.options.experimental_prefetchInRender){const h=R=>{f.status==="error"?R.reject(f.error):f.data!==void 0&&R.resolve(f.data)},S=()=>{const R=this.#r=f.promise=L();h(R)},y=this.#r;switch(y.status){case"pending":e.queryHash===s.queryHash&&h(y);break;case"fulfilled":(f.status==="error"||f.data!==y.value)&&S();break;case"rejected":(f.status!=="error"||f.error!==y.reason)&&S();break}}return f}updateResult(){const e=this.#t,t=this.createResult(this.#e,this.options);if(this.#o=this.#e.state,this.#u=this.options,this.#o.data!==void 0&&(this.#d=this.#e),U(t,e))return;this.#t=t;const s=()=>{if(!e)return!0;const{notifyOnChangeProps:r}=this.options,i=typeof r=="function"?r():r;if(i==="all"||!i&&!this.#p.size)return!0;const u=new Set(i??this.#p);return this.options.throwOnError&&u.add("error"),Object.keys(this.#t).some(n=>{const g=n;return this.#t[g]!==e[g]&&u.has(g)})};this.#P({listeners:s()})}#R(){const e=this.#s.getQueryCache().build(this.#s,this.options);if(e===this.#e)return;const t=this.#e;this.#e=e,this.#f=e.state,this.hasListeners()&&(t?.removeObserver(this),e.addObserver(this))}onQueryUpdate(){this.updateResult(),this.hasListeners()&&this.#x()}#P(e){X.batch(()=>{e.listeners&&this.listeners.forEach(t=>{t(this.#t)}),this.#s.getQueryCache().notify({query:this.#e,type:"observerResultsUpdated"})})}};function oe(e,t){return d(t.enabled,e)!==!1&&e.state.data===void 0&&!(e.state.status==="error"&&t.retryOnMount===!1)}function K(e,t){return oe(e,t)||e.state.data!==void 0&&M(e,t,t.refetchOnMount)}function M(e,t,s){if(d(t.enabled,e)!==!1&&v(t.staleTime,e)!=="static"){const r=typeof s=="function"?s(e):s;return r==="always"||r!==!1&&N(e,t)}return!1}function B(e,t,s,r){return(e!==t||d(r.enabled,e)===!1)&&(!s.suspense||e.state.status!=="error")&&N(e,s)}function N(e,t){return d(t.enabled,e)!==!1&&e.isStaleByTime(v(t.staleTime,e))}function ae(e,t){return!U(e.getCurrentResult(),t)}var J=m.createContext(!1),ce=()=>m.useContext(J);J.Provider;function le(){let e=!1;return{clearReset:()=>{e=!1},reset:()=>{e=!0},isReset:()=>e}}var ue=m.createContext(le()),he=()=>m.useContext(ue),de=(e,t)=>{(e.suspense||e.throwOnError||e.experimental_prefetchInRender)&&(t.isReset()||(e.retryOnMount=!1))},pe=e=>{m.useEffect(()=>{e.clearReset()},[e])},fe=({result:e,errorResetBoundary:t,throwOnError:s,query:r,suspense:i})=>e.isError&&!t.isReset()&&!e.isFetching&&r&&(i&&e.data===void 0||se(s,[e.error,r])),me=e=>{if(e.suspense){const s=i=>i==="static"?i:Math.max(i??1e3,1e3),r=e.staleTime;e.staleTime=typeof r=="function"?(...i)=>s(r(...i)):s(r),typeof e.gcTime=="number"&&(e.gcTime=Math.max(e.gcTime,1e3))}},ge=(e,t)=>e.isLoading&&e.isFetching&&!t,be=(e,t)=>e?.suspense&&t.isPending,q=(e,t,s)=>t.fetchOptimistic(e).catch(()=>{s.clearReset()});function ye(e,t,s){const r=ce(),i=he(),u=re(),n=u.defaultQueryOptions(e);u.getDefaultOptions().queries?._experimental_beforeQuery?.(n),n._optimisticResults=r?"isRestoring":"optimistic",me(n),de(n,i),pe(i);const g=!u.getQueryCache().get(n.queryHash),[c]=m.useState(()=>new t(u,n)),p=c.getOptimisticResult(n),o=!r&&e.subscribed!==!1;if(m.useSyncExternalStore(m.useCallback(x=>{const l=o?c.subscribe(X.batchCalls(x)):D;return c.updateResult(),l},[c,o]),()=>c.getCurrentResult(),()=>c.getCurrentResult()),m.useEffect(()=>{c.setOptions(n)},[n,c]),be(n,p))throw q(n,c,i);if(fe({result:p,errorResetBoundary:i,throwOnError:n.throwOnError,query:u.getQueryCache().get(n.queryHash),suspense:n.suspense}))throw p.error;return u.getDefaultOptions().queries?._experimental_afterQuery?.(n,p),n.experimental_prefetchInRender&&!k&&ge(p,r)&&(g?q(n,c,i):u.getQueryCache().get(n.queryHash)?.promise)?.catch(D).finally(()=>{c.updateResult()}),n.notifyOnChangeProps?p:c.trackResult(p)}function T(e,t){return ye(e,ne)}function Ue({showBackButton:e=!1,backButtonText:t="돌아가기"}){const s=ie();return a.jsx("nav",{className:"bg-white/80 backdrop-blur-sm shadow-sm fixed w-full top-0 z-50",children:a.jsx("div",{className:"max-w-6xl mx-auto px-6 py-4",children:a.jsxs("div",{className:"flex justify-between items-center",children:[a.jsx("button",{onClick:()=>s("/"),className:"font-bold text-2xl text-purple-600 hover:scale-105 transform transition-all duration-300 cursor-pointer",children:"☀️"}),e?a.jsxs("button",{onClick:()=>s("/"),className:"flex items-center space-x-2 text-gray-700 hover:text-purple-600 hover:scale-105 transform transition-all duration-300 cursor-pointer",children:[a.jsx("i",{className:"ri-arrow-left-line text-xl"}),a.jsx("span",{children:t})]}):a.jsxs("div",{className:"hidden md:flex space-x-8",children:[a.jsx("a",{href:"#about",className:"text-gray-700 hover:text-purple-400 transition-all duration-300 hover:scale-105 cursor-pointer",children:"소개"}),a.jsx("a",{href:"#experience",className:"text-gray-700 hover:text-purple-400 transition-all duration-300 hover:scale-105 cursor-pointer",children:"경력"}),a.jsx("a",{href:"#projects",className:"text-gray-700 hover:text-purple-400 transition-all duration-300 hover:scale-105 cursor-pointer",children:"프로젝트"}),a.jsx("a",{href:"#contact",className:"text-gray-700 hover:text-purple-400 transition-all duration-300 hover:scale-105 cursor-pointer",children:"연락처"})]}),a.jsx("button",{className:"md:hidden hover:rotate-180 transition-transform duration-300",children:a.jsx("i",{className:"ri-menu-line text-2xl text-gray-700"})})]})})})}function De(){return a.jsx("footer",{className:"bg-white py-8 px-6",children:a.jsx("div",{className:"max-w-6xl mx-auto",children:a.jsx("div",{className:"flex flex-col md:flex-row justify-end items-center",children:a.jsx("p",{className:"text-gray-600 mb-4 md:mb-0",children:"© 2025 Park Haebeen"})})})})}const xe="/portfolio/assets/butter-logo-DAKwGqM5.png",ve="/portfolio/assets/jiransoft-logo-CTWEcLyT.png",Se="/portfolio/assets/lgu1-B4A5f2n7.png",G="/portfolio/assets/lgu2-44iI3FAj.png",$="/portfolio/assets/xkeeper1-Due0X3id.png",Re="/portfolio/assets/xkeeper2-BrietgPG.png",z=[{name:"버터",position:"프론트엔드 개발자 | 대리",period:"2024.03 - 재직중",description:"대규모 멤버십 플랫폼, 브라우저, 실시간 감독 시스템, 온라인 시험 플랫폼 등 아키텍처 설계 및 React/Vue 프론트엔드 개발을 담당했습니다.",logo:xe},{name:"지란지교소프트",position:"프론트엔드 개발자 | 사원",period:"2018.12 - 2022.07",description:"React/TypeScript 도입, Nuxt 리팩토링과 결제 시스템 구현, 실시간 기능 개발 및 CS팀과의 협업을 통한 사용자 경험 개선을 담당했습니다.",logo:ve}],C=[{id:1,title:"LG유플러스 멤버십 통합 서비스",description:"LG유플러스 멤버십 앱 기능을 유플닷컴으로 내재화한 앱 내 웹뷰 기반 통합 서비스 입니다.",detailedDescription:"VIP콕, 멤버십 사용처, 유플투쁠 이벤트 등 핵심 기능들을 웹뷰로 통합하여 사용자 경험을 일원화했습니다. React Suspense와 TanStack Query를 활용한 상태 관리 최적화, 무한스크롤 페이지네이션 구현, 그리고 멤버십 차등 정책에 따른 복잡한 사용자 상태 관리까지 VIP콕 프론트엔드를 담당했습니다.",tech:["Next.js","React","TypeScript","Zustand","SCSS","Storybook"],period:"2024.12 - 진행중",role:"Frontend Developer",challenges:["vue2로 되어있던 페이지를 react로 리팩토링","iOS WebView 백화 현상 해결 (position: sticky GPU 컴포지팅 레이어 이슈)","멤버십 차등 정책에 따른 복잡한 사용자 상태 관리"],contributions:["VIP콕 서비스 메인/상세 페이지 개발","멤버십 등급에 따른 차등 정책 분기처리 로직 구현 (훅으로 사용자 상태 관리)","영화예매, 충전하기, 선물하기 등 다양한 혜택 유형별 컴포넌트 분리 설계","유플투쁠 이벤트 시스템 개발 및 운영 개선"],images:[G,Se],githubUrl:"",liveUrl:"",imageUrl:G,reflection:["이 프로젝트를 통해 가장 큰 깨달음은 '문제의 본질을 파악하는 것의 중요성'이었습니다. iOS WebView 백화 현상을 해결할 때, 처음에는 데이터 로딩 문제로 오해하고 글로벌 로딩 컴포넌트를 제거하고 React Suspense를 적용하는 등 여러 시행착오를 겪었습니다. 하지만 결국 근본 원인을 찾아내고, position: sticky 요소의 GPU 컴포지팅 레이어 생성 과정에서 iOS WebKit의 paint invalidation 실패가 원인임을 파악할 수 있었습니다.","또한 '단순한 해결책이 때로는 최고의 해결책'이라는 것을 배웠습니다. 복잡한 CSS 변경이나 DOM 조작 대신 window.scrollTo()라는 단순한 API로 문제를 해결할 수 있었던 것처럼, 과도한 엔지니어링보다는 문제의 핵심을 정확히 파악하는 것이 중요하다는 것을 깨달았습니다. 이는 앞으로 어떤 기술적 도전을 만나더라도 근본 원인을 찾아내는 사고방식을 기르는 데 큰 도움이 되었습니다.","기술적으로는 React/Next.js 생태계의 깊이를 이해하게 되었고, 특히 Suspense와 Error Boundary를 활용한 에러 처리, TanStack Query의 캐싱 전략, 그리고 WebView 환경의 특수성을 고려한 개발 방법론을 익힐 수 있었습니다.","팀 협업 측면에서는 복잡한 이슈를 체계적으로 분석하고 해결하는 과정에서 동료들과의 소통과 지식 공유의 중요성을 다시 한번 느꼈습니다. 특히 iOS WebView 이슈 해결 과정에서 팀원들과 함께 문제를 분석하고, 다양한 접근 방법을 시도해보며 최종 해결책을 찾아가는 과정에서 팀워크의 가치를 깊이 체감했습니다. 앞으로도 이런 협업을 통해 더 나은 솔루션을 만들어갈 수 있을 것 같습니다."]},{id:2,title:"고사장 브라우저 (시험 감독용 보안 브라우저)",description:"시험 부정행위 방지를 위한 보안 브라우저로, 운영체제 레벨 보안 모듈을 통합하여 키보드/마우스 입력 차단, 화면 캡처 방지, 클립보드 제어 등 다중 보안 계층을 구현한 Electron 기반 데스크톱 애플리케이션입니다.",detailedDescription:"이 프로젝트는 온라인 시험 환경에서 응시자의 부정행위를 방지하기 위한 보안 브라우저 개발입니다.",tech:["Electron","React","TypeScript","Node.js","Express.js"],period:"2024.03 ~ 2025.08",role:"Frontend Developer",challenges:["일렉트론 내부에서 웹사이트를 띄워 크롬의 일부분 기능을 구현"],contributions:["Electron 기반 보안 모듈 시스템 개발 (키보드/마우스 입력 차단, 화면 캡처 방지 등)","WebContents → WebView: UI 가려짐 문제 해결을 위한 아키텍처 개선","실시간 상태 모니터링: 웹캠, 화면공유, 스마트폰 연결 상태 실시간 표시"],images:[],githubUrl:"",liveUrl:"",imageUrl:"",reflection:["기술적으로는 Electron 생태계의 깊이를 이해하게 되었고, 특히 네이티브 모듈 통합, IPC 통신, 크로스 플랫폼 개발의 복잡성을 경험했습니다. Rust와 TypeScript를 함께 사용하면서 각 언어의 장점을 살린 하이브리드 개발 방법론을 익힐 수 있었고, Inspector 패턴을 활용한 확장 가능한 보안 모듈 아키텍처 설계 능력을 기를 수 있었습니다.","WebContents의 한계를 극복하기 위해 WebView로 변환하면서, Electron의 다양한 렌더링 방식을 이해하게 되었습니다. WebContents는 메인 프로세스에서 직접 제어되어 UI 레이어 분리가 불가능했지만, WebView는 독립적인 렌더링 컨텍스트를 제공하여 브라우저 UI와 웹 콘텐츠를 완전히 분리할 수 있었습니다. 특히 WebView의 이벤트 처리(did-finish-load, will-navigate)와 조건부 렌더링을 통한 메모리 최적화 방법을 익히면서, Electron의 IPC 통신 시스템과 멀티 탭 환경에서의 성능 최적화 기법을 습득할 수 있었습니다."]},{id:3,title:"고사장 프록터 웹 시스템 (실시간 감독 플랫폼)",description:"온라인 시험 환경에서 감독관이 응시자를 실시간으로 모니터링할 수 있는 웹 기반 감독 시스템입니다. WebRTC 기반 멀티 스트림 관리, Socket.IO 실시간 통신, 동적 그리드 레이아웃을 통해 PC와 모바일 기기에서 동시에 전송되는 비디오/오디오 스트림을 화면에 보여주며, 실시간 채팅과 상태 동기화를 제공합니다.",detailedDescription:"감독관이 응시자를 모니터링하는 실시간 감시 서비스 입니다",tech:["Vue 3","TypeScript","Pinia","Socket.IO","WebRTC","PrimeVue","SCSS","Vite"],period:"2024.03 ~ 2025.08",role:"Frontend Developer",challenges:["WebRTC 멀티 스트림 동기화 및 DOM 참조 문제","폴링 방식의 서버 부하 증가 및 실시간성 부족","동적 그리드 레이아웃에서 비동기 처리로 인한 UI 업데이트 지연"],contributions:["WebRTC 기반 멀티 스트림 실시간 감독 시스템 개발 (PC/모바일 동시 지원)","폴링에서 Socket.IO 기반 실시간 통신으로 전환하여 네트워크 트래픽 감소","vue3-grid-layout-next를 활용한 동적 화면 배치 및 실시간 레이아웃 조정 구현","실시간 채팅, 알림, 상태 변경을 통한 감독 효율성 향상 및 사용자 경험 개선"],images:[],githubUrl:"",liveUrl:"",imageUrl:"",reflection:["프로젝트에서 구현에서 문제를 겪었던 일은 '실시간 미디어 스트림 처리의 복잡성'이었습니다. WebRTC 멀티 스트림 관리에서 스트림 동기화와 DOM 참조 문제를 해결할 때, 단순히 코드 로직만 수정하는 것이 아니라 `nextTick`을 활용한 비동기 DOM 업데이트와 동적 ref 할당까지 전체적인 아키텍처를 이해해야 해결할 수 있다는 것을 배웠습니다. 특히 `createLayout` 함수에서 `videoRefs.value[newItemIndex]`를 참조할 때 발생하는 타이밍 이슈를 해결하기 위해 `await nextTick()`을 사용하여 DOM 업데이트를 보장하는 과정에서, 실시간 시스템에서는 예측하기 어려운 타이밍 이슈들이 발생하므로 전체적인 흐름을 파악하는 것이 중요하다는 것을 깨달았습니다.","또한 '폴링과 소켓 통신의 장단점 분석'을 통해 최적의 통신 방식을 선택하는 과정에서 시스템 아키텍처 설계의 중요성을 배웠습니다. 기존 폴링 방식에서 5초마다 API를 호출하던 것을 Socket.IO 기반 실시간 통신으로 전환하여 네트워크 트래픽을 감소시키고 응답 속도를 개선할 수 있었습니다. 이 과정에서 기술적 선택이 비즈니스 성과에 미치는 영향을 직접 경험할 수 있었습니다."]},{id:4,title:"온라인 시험 플랫폼 (ONTP) - 응시자 웹 시스템",description:"실시간 감시(Proctoring) 시스템을 통한 온라인 시험 플랫폼으로, WebRTC 기반 화면 공유와 Socket.io를 활용한 실시간 통신을 구현했습니다. 8가지 문항 유형을 지원하며 글로벌 시험 환경을 위한 타임존 처리와 크로스 플랫폼 호환성을 확보한 Vue 3 기반 하이브리드 웹 애플리케이션입니다.",detailedDescription:"이 프로젝트는 코로나19로 인한 비대면 시험 환경의 급증에 대응하여 개발된 대규모 온라인 시험 플랫폼입니다. 월 수만 명의 응시자가 이용하는 시스템으로, 실시간 감시를 통한 부정행위 방지와 다양한 문항 유형 지원이 핵심입니다. Vue 3 Composition API와 Pinia를 활용한 상태 관리, Proctor SDK v3를 통한 WebRTC 기반 실시간 감시, Socket.io를 통한 실시간 채팅 시스템을 구현했습니다. 특히 iOS WebKit 환경에서의 타이머 동기화 문제, 소켓 통신의 중복 API 호출 이슈, 그리고 글로벌 시험을 위한 타임존 처리 등 복잡한 기술적 도전들을 해결하며 전체 프론트엔드 아키텍처를 담당했습니다.",tech:["Vue 3","TypeScript","Pinia","WebRTC","Socket.io","SCSS","Vite 5","Proctor SDK v3","Face-api.js"],period:"2024.03 ~ 2025.08",role:"Frontend Developer (유지보수 및 기능 개선)",challenges:["실시간 타이머 동기화 문제로 인한 '잔여 시간이 실제와 다르게 표시'되는 이슈","소켓 통신에서 채팅 열기 + 메시지 수신 시 API 중복 호출 문제","iOS WebKit 환경에서의 브라우저 호환성 및 렌더링 이슈","Proctor SDK v3 통합 시 WebRTC 연결 실패 및 오류 처리 복잡성","글로벌 시험 환경을 위한 타임존 처리 및 크로스 플랫폼 호환성"],contributions:["실시간 타이머 동기화 시스템 구축으로 서버-클라이언트 시간 불일치 문제 해결","소켓 통신 최적화로 API 중복 호출 방지 및 성능 개선","30개 이상 컴포넌트에 걸친 포괄적 로깅 시스템 구축으로 디버깅 효율성 향상","디바이스 정보 수집 시스템 구현으로 다양한 모바일 환경 지원","Proctor SDK 오류 처리 강화로 WebRTC 연결 안정성 40% 개선"],images:[],githubUrl:"",liveUrl:"",imageUrl:"",reflection:["이 프로젝트를 통해 가장 큰 깨달음은 '유지보수 작업의 중요성과 복잡성'이었습니다. 처음에는 단순한 버그 수정으로 생각했던 타이머 동기화 문제가 실제로는 서버와 클라이언트 간의 시간 동기화 메커니즘 전체를 재검토해야 하는 복잡한 이슈였습니다. 1초마다 서버 시간을 폴링하는 시스템을 구축하면서 실시간 시스템의 예측하기 어려운 특성을 깊이 이해하게 되었습니다.","또한 '소켓 통신의 중복 API 호출 문제'를 해결하면서 이벤트 기반 아키텍처에서 발생할 수 있는 부작용들을 경험했습니다. 단순히 API 호출을 제거하는 것이 아니라, 채팅 열기와 소켓 메시지 수신이라는 두 가지 이벤트가 언제 발생하는지 정확히 파악하고, innerVisible.value 조건을 추가하여 적절한 시점에만 API가 호출되도록 수정했습니다. 이 과정에서 '이벤트 흐름의 정확한 이해'가 얼마나 중요한지 깨달았습니다.","기술적으로는 Vue 3 Composition API의 장점을 실무에서 체감할 수 있었습니다. 특히 watch 함수의 복잡한 의존성 관리와 nextTick을 활용한 DOM 업데이트 타이밍 제어 등, 프레임워크의 세부 기능들을 깊이 이해하게 되었습니다. 또한 WebRTC와 Socket.io를 조합한 실시간 통신 시스템에서 발생하는 네트워크 불안정성과 브라우저 호환성 문제를 해결하면서, 크로스 플랫폼 개발의 어려움과 해결 방법을 학습할 수 있었습니다.","팀 협업 측면에서는 기존 코드베이스를 이해하고 개선하는 과정에서 '레거시 코드와의 소통'의 중요성을 느꼈습니다. 30개 이상의 컴포넌트에 로깅 시스템을 추가하면서 기존 개발자들의 의도를 파악하고, 최소한의 변경으로 최대한의 효과를 얻는 방법을 고민했습니다. 특히 Proctor SDK 업데이트 과정에서 41개 파일을 수정하면서, 외부 라이브러리와의 통합 시 발생하는 복잡성을 체험하고 이를 체계적으로 관리하는 방법을 익혔습니다."]},{id:5,title:"온라인 시험 감독 시스템",description:"기업 관리자가 시험과 응시자 환경을 관리하는 서비스로, 실시간 감독 영상 모니터링과 멀티 비디오 동기화 플레이어를 통해 시험의 투명성과 공정성을 보장하는 시스템입니다.",detailedDescription:"이 프로젝트는 온라인 시험의 감독 과정을 디지털화하여 관리자가 PC화면, 정면감독, 주변감독 3개 카메라의 영상을 실시간으로 모니터링할 수 있는 시스템입니다. 가장 핵심적인 기능은 서로 다른 시작/종료 시간을 가진 여러 비디오 스트림을 하나의 타임라인으로 통합하여 동기화 재생하는 것입니다. Vue 3 Composition API와 HTML5 Video API를 활용하여 복잡한 시간축 계산과 상태 관리를 구현했으며, 감독 메모와 채팅 이벤트를 타임라인에 시각적으로 표시하고 해당 시점으로 즉시 이동할 수 있는 기능을 제공합니다. 또한 응시자의 디바이스/네트워크/리소스 상태를 실시간으로 모니터링하여 시험 환경의 안정성을 보장합니다.",tech:["Vue 3","TypeScript","HTML5 Video API","Moment.js","SCSS","Vite","PrimeVue"],period:"2024.03 ~ 2025.08",role:"Frontend Developer",challenges:["3개 독립 비디오 스트림의 실시간 동기화 구현","서로 다른 시작/종료 시간을 가진 비디오들의 타임라인 통합","복잡한 시간축 계산 로직으로 정확한 재생 위치 제어","대용량 비디오 스트림의 메모리 효율적 관리","실시간 이벤트 마킹과 타임라인 연동","iOS WebView 환경에서의 비디오 재생 최적화"],contributions:["멀티 비디오 동기화 플레이어 개발로 감독 효율성 50% 향상","실시간 타임라인 이벤트 마킹으로 감독 메모/채팅 추적 정확도 개선","복잡한 시간축 계산 알고리즘 구현으로 정밀한 비디오 제어 가능","Vite 기반 빌드 최적화로 개발 환경 성능 40% 개선","반응형 UI 구현으로 다양한 디바이스에서 안정적인 감독 환경 제공","메모리 효율적인 비디오 참조 관리로 장시간 사용 시 안정성 확보"],images:[],githubUrl:"",liveUrl:"",imageUrl:"",reflection:["이 프로젝트를 통해 가장 큰 깨달음은 '복잡한 멀티미디어 동기화의 기술적 도전'이었습니다. 3개의 독립적인 비디오 스트림을 하나의 컨트롤러로 관리하면서, 각 비디오의 시작/종료 시간이 다르다는 점이 가장 큰 기술적 난제였습니다. 처음에는 단순히 currentTime을 동기화하는 것으로 충분할 것이라고 생각했지만, 실제로는 각 비디오의 절대 시간을 기준으로 상대 시간을 계산하는 복잡한 알고리즘이 필요했습니다.","특히 '시간축 통합의 복잡성'을 깊이 이해하게 되었습니다. 서로 다른 시점에 녹화된 비디오들을 하나의 타임라인으로 통합하려면, 각 비디오의 시작 시간을 기준으로 한 상대적 시간 계산이 핵심이었습니다. Moment.js를 활용한 Unix 타임스탬프 계산과 비디오의 duration을 고려한 정확한 재생 위치 제어 로직을 구현하는 과정에서 시간 기반 데이터 처리의 깊이를 배웠습니다.","기술적으로는 Vue 3 Composition API의 진정한 가치를 체감했습니다. 복잡한 상태 관리와 비디오 참조 관리에서 reactive와 ref의 차이점, 그리고 nextTick을 활용한 DOM 업데이트 최적화 등 실무에서 바로 적용할 수 있는 구체적인 기술들을 습득했습니다. 또한 HTML5 Video API의 제약사항과 브라우저별 차이점을 이해하게 되었고, 특히 iOS WebView 환경에서의 비디오 재생 최적화 경험은 매우 소중했습니다.","사용자 경험 측면에서는 '복잡한 기술 뒤에 숨은 직관적 인터페이스'의 중요성을 깨달았습니다. 기술적으로는 매우 복잡한 동기화 로직이지만, 사용자에게는 단순한 슬라이더 조작으로 모든 비디오를 제어할 수 있도록 만드는 것이 핵심이었습니다. 또한 실시간 이벤트 마킹을 통해 감독자가 특정 시점의 상황을 빠르게 파악할 수 있도록 하는 UX 설계 경험을 쌓을 수 있었습니다.","팀 협업 측면에서는 '기술적 복잡성을 팀원들과 공유하는 방법'을 배웠습니다. 멀티미디어 동기화라는 비교적 생소한 기술 영역을 팀원들과 함께 분석하고 해결해가는 과정에서, 복잡한 기술을 이해하기 쉽게 설명하고 공유하는 소통 능력의 중요성을 깨달았습니다. 앞으로도 이런 협업을 통해 더 나은 솔루션을 만들어갈 수 있을 것 같습니다."]},{id:6,title:"통합운영시스템",description:"지란지교소프트의 오피스웨어 및 관련 제품들을 관리하는 사이트로, 메신저 봇 관리, 메시지 용량 통계, 사용자 및 IP 관리, 결제 취소 기능 등을 제공하는 시스템입니다.",detailedDescription:"이 프로젝트는 회사 내부에서 사용하는 통합 관리 시스템으로, 기획부터 디자인, 화면 구성까지 팀원들과 협업하여 개발했습니다. next-auth 기반 인증, Ant Design UI 구성, axios를 통한 서버 통신 등을 구현했습니다. 팀 내 역할 변화로 인해 서버와 프론트엔드 구분이 모호해진 상황에서 서버 환경 세팅 및 로컬 로그 분석을 통해 문제를 해결하며 서버 이해도를 넓힐 수 있었습니다.",tech:["React","TypeScript","Ant Design","Next-Auth","Axios","Git","Jira"],period:"2022.04 ~ 2022.07",role:"Frontend Developer",challenges:["React와 TypeScript를 처음 도입하며 프로젝트 초기 세팅 및 적용","서버/프론트 구분 없는 팀 환경에서 유연하게 대응","next-auth를 활용한 인증 처리","Ant Design을 이용한 UI/UX 구성","서버 로그 기반 디버깅 및 문제 해결"],contributions:["프론트엔드 주요 기능 개발 (로그인/로그아웃, UI 구성)","Ant Design 기반 사용자 친화적 UI/UX 구현","서버 통신 및 로컬 환경 로그 분석을 통한 문제 해결","팀 내 의사소통 및 협업 과정에서 의견 수용 능력 향상"],images:[],githubUrl:"",liveUrl:"",imageUrl:"",reflection:["React와 TypeScript를 처음 사용한 프로젝트로, 실무 적용 경험을 쌓을 수 있었습니다.","팀원들과 기획, 디자인, 화면 구성까지 논의하며 협업 과정의 중요성을 배웠습니다.","서버/프론트 구분이 없는 환경에서 서버 환경 세팅과 로그 분석을 통해 문제 해결 능력을 키웠습니다.","PHP 서버 코드를 직접 작성하지는 않았지만, 서버 측 동작을 이해하고 코드 전반을 넓게 바라보는 시야를 얻었습니다."]},{id:7,title:"Xkeeper 홈페이지 리팩토링",description:"엑스키퍼 제품 홈페이지를 Nuxt 기반으로 리팩토링하여 기능 소개, 자녀 사용 제어 및 보고서 제공, 구매 기능 등을 포함한 사용자 친화적인 웹사이트를 개발했습니다.",detailedDescription:"이 프로젝트는 기존에 존재하던 Xkeeper 홈페이지를 Nuxt 기반으로 리팩토링한 작업입니다. 주요 기능으로는 자녀의 PC/모바일 사용 시간 제어, 사용 기록 리포트 제공, 위치 서비스(구글맵 & 카카오맵 API), 실시간 데스크탑 화면 캡쳐(socket.io), 이니시스 결제, 구글 리캡챠 보안 강화 등이 있습니다. 프론트엔드 전반을 담당하며 사용자 경험 향상에 집중하였습니다.",tech:["Nuxt","Sass","JavaScript","Axios","Lodash","PHP","Git","Sonar","Sentry","Jira"],period:"2020.01 ~ 2022.04",role:"Frontend Developer",challenges:["기존 홈페이지를 Nuxt 기반으로 리팩토링","구글맵과 카카오 지도 API를 조합해 위치 서비스 구현","socket.io를 활용한 실시간 데스크탑 화면 캡쳐 기능","이니시스 결제를 통한 구매 기능 구현","구글 리캡챠 기반 로그인 보안 강화","CS팀과 협업을 통해 고객 피드백을 직접 반영"],contributions:["홈페이지 프론트엔드 전체 리팩토링 (90% 이상 기여)","구글맵 API와 카카오 지도 API를 결합하여 직관적인 위치 서비스 제공","socket.io 기반 실시간 자녀 PC 화면 캡쳐 기능 개발","이니시스 결제 프로세스 구현으로 상용 결제 경험 확보","구글 리캡챠 적용으로 보안 강화","사용자 경험 개선을 위해 CS팀과 협업하여 고객 피드백 반영"],images:[$,Re],githubUrl:"",liveUrl:"https://xkeeper.com/",imageUrl:$,reflection:["처음으로 이니시스 결제 기능을 개발하며 결제 프로세스에 대한 이해를 넓혔습니다.","기존에는 내부 시스템 개발 위주였지만, 실제 외부 사용자들이 이용하는 홈페이지를 개발하면서 사용자와 더 가까워졌다는 보람을 느꼈습니다.","홈페이지 오류 발생 시 고객센터로 직접 문의가 들어오기 때문에 CS팀과 협업하며 고객들의 생생한 목소리를 들을 수 있었고, 이를 바탕으로 더 나은 사용자 경험을 제공할 수 있었습니다."]}],I={getCompanies:async()=>(await new Promise(e=>setTimeout(e,100)),z),getProjects:async()=>(await new Promise(e=>setTimeout(e,100)),C),getProject:async e=>(await new Promise(t=>setTimeout(t,100)),C.find(t=>t.id===e)||null),updateCompany:async(e,t)=>(await new Promise(s=>setTimeout(s,200)),console.log(`Company ${e} updated:`,t),z[0]),updateProject:async(e,t)=>(await new Promise(s=>setTimeout(s,200)),console.log(`Project ${e} updated:`,t),C.find(s=>s.id===e)||null),getOtherProjects:async e=>(await new Promise(t=>setTimeout(t,100)),C.filter(t=>t.id!==e))},O={companies:["companies"],projects:["projects"],project:e=>["project",e]},Pe=()=>T({queryKey:O.companies,queryFn:I.getCompanies,staleTime:1e3*60*5}),Ce=()=>T({queryKey:O.projects,queryFn:I.getProjects,staleTime:1e3*60*5}),Te=e=>T({queryKey:O.project(e),queryFn:()=>I.getProject(e),enabled:!!e,staleTime:1e3*60*5}),Ie=e=>T({queryKey:[...O.projects,"others",e],queryFn:()=>I.getOtherProjects(e),enabled:!!e,staleTime:1e3*60*5}),ke=()=>{const e=Pe(),t=Ce();return{companies:e.data||[],projects:t.data||[],isLoading:e.isLoading||t.isLoading,isError:e.isError||t.isError,error:e.error||t.error}},Me=e=>{const t=Te(e),s=Ie(e);return{project:t.data,otherProjects:s.data||[],isLoading:t.isLoading||s.isLoading,isError:t.isError||s.isError,error:t.error||s.error}},Oe={default:"bg-gray-100 text-gray-700",blue:"bg-blue-100 text-blue-700",purple:"bg-purple-100 text-purple-700",pink:"bg-pink-100 text-pink-700",indigo:"bg-indigo-100 text-indigo-700",red:"bg-red-100 text-red-700",green:"bg-green-100 text-green-700"},je={sm:"px-2 py-1 text-xs",md:"px-3 py-1 text-sm",lg:"px-4 py-2 text-sm"};function Ne({children:e,variant:t="default",size:s="md",className:r="",onClick:i}){const u="rounded-full font-medium hover:scale-110 transform transition-all duration-300",n=Oe[t],g=je[s],c=i?"cursor-pointer":"";return a.jsx("span",{className:`${u} ${n} ${g} ${c} ${r}`,onClick:i,children:e})}export{Ne as C,De as F,Ue as H,Me as a,ke as u};
//# sourceMappingURL=Chip-BcG8sIqJ.js.map
